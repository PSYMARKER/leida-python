<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyleida._leida API documentation</title>
<meta name="description" content="Class to execute the LEiDA pipeline." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>pyleida.Leida</code></h1>
</header>
<section id="section-intro">
<p>Class to execute the LEiDA pipeline.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Class to execute the LEiDA pipeline.&#34;&#34;&#34;

import numpy as np 
import pandas as pd
import os
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.utils import Bunch
from itertools import combinations

import warnings
warnings.filterwarnings(&#34;ignore&#34;)

from .dynamics_metrics import (
    group_transition_matrix,
    compute_dynamics_metrics,
) 
from .data_utils import (
    load_tseries,
    load_classes,
    load_rois_labels,
    load_rois_coordinates
)
from .clustering import (
    identify_states,
    plot_clusters3D,
    centroid2matrix,
    plot_voronoi,
    barplot_states,
    barplot_eig,
    plot_clustering_scores
)
from .clustering import rsnets_overlap as rsnets
from .plotting import (
    brain_states_nodes,
    brain_states_network,
    states_in_bold,
    plot_pyramid,
    states_k_glass,
    brain_states_on_surf,
    brain_states_on_surf2,
    _explore_state,
    _save_html
)
from .signal_tools import (
    hilbert_phase,
    phase_coherence,
    get_eigenvectors
)
from .data_utils.validation import (
    _check_k_input,
    _check_metric,
    _check_state
)
from .stats import _compute_stats,scatter_pvalues

class Leida:
    &#34;&#34;&#34;
    Class to execute the LEiDA pipeline
    and explore the results.

    Params:
    -------
    data_path : str.
        Path to the folder that contains the time
        series, ROIs labels and coordinates, and
        the group/condition of each subject.

    Attributes:
    -----------
    eigenvectors : pandas.dataframe.
        Contains the computed eigenvectors.

    predictions : pandas.dataframe.
        Contains the predicted cluster label of
        each eigenvector for each &#39;k&#39; partition
        explored.

    rois_labels : list.
        The label/name of each ROI/parcel.

    rois_coordinates : ndarray of shape (n_rois,3).
        The MNI coordinates of each ROI/parcel.

    time_series : dict.
        Contains the BOLD signals of each subject.
        The keys are the subject id&#39;s, and the values
        are numpy 2D arrays (N_ROIs, N_volumes) with
        the time series of each brain region/parcel.

    classes : dict.
        Contains the condition/group label/s
        of each subject.
        Keys are subject id&#39;s.

    &#34;&#34;&#34;
    def __init__(self,data_path):
        if not isinstance(data_path,str):
            raise TypeError(&#34;&#39;data_path&#39; must be a string!&#34;)
        else:
            if not os.path.exists(data_path):
                raise ValueError(f&#34;The specified path could&#39;t be founded.&#34;)

        self.time_series = load_tseries(data_path)
        self.classes = load_classes(data_path)
        self.rois_labels = load_rois_labels(data_path)
        self.rois_coordinates = load_rois_coordinates(data_path)

        self._validate_constructor_params() #check if the data has been loaded sucessfully.

    def fit_predict(self,TR=None,paired_tests=False,n_perm=5_000,save_results=True,random_state=None):
        &#34;&#34;&#34;
        Execute the LEiDA pipeline: 
            1) Compute the instantaneous phase of each signal, the
            phase-coherence matrices, and extract the eigenvectors.

            2) Fit a k-means model for each k partition, identify
            the phase-locking (PL) states (centroids), and assign
            a cluster label to each observation (eigenvectors).

            3) Compute the dwell times, occupancies, and transitions
            probabilities for each &#39;k&#39; partition.

            4) Perform a statistical analysis of occupancies and
            dwell times for each &#39;k&#39; partition.

        Params:
        -------
        TR : None | np.float | int.
            Specify the Repetition Time of the fMRI data.
            If &#39;None&#39;, then the dwell times will express the mean
            lifetime of each PL state in TR units, instead of seconds.

        paired_tests : bool. Default: False.
            Specify if groups are independent or related/paired,
            to run the correct statistical tests.

        n_perm : int.
            Select the number of permutations that will be applied
            when running the statistical analysis of dwell times
            and occupancies for each k.

        save_results : bool.
            Whether to create folders and files to save the
            results on local folder. If True, then a folder
            called &#39;LEiDA_results&#39; containing all the results
            will be created. Note: These results can be easely
            retrieved later using the &#39;DataLoader&#39; class.

        random_state : None | int.
            Determines random number generation for centroid
            initialization. Use an int to make the randomness
            deterministic.
        &#34;&#34;&#34;
        self._K_min_ = 2
        self._K_max_ = 20
        
        #validate provided &#39;TR&#39;
        if TR is not None and not isinstance(TR,(int,float)):
            raise TypeError(&#34;&#39;TR&#39; must be &#39;None&#39;, and integer or a floating number!&#34;)

        #validate paired_tests input
        if not isinstance(paired_tests,bool):
            raise TypeError(&#34;&#39;paired_tests&#39; must be either True or False.&#34;)
        
        #check that a valid number of permutations was provided
        if not isinstance(n_perm,int):
            raise TypeError(&#34;&#39;n_perm&#39; must be an integer!&#34;)
        else:
            if n_perm&lt;100:
                raise ValueError(&#34;The number of permutations cannot be lower than 100.&#34;)

        #validate &#39;save_results&#39; input
        if not isinstance(save_results,bool):
            raise TypeError(&#34;&#39;save_results&#39; must be a boolean value (True or False)!&#34;)

        #Run the analysis
        self._results_path_ = &#39;LEiDA_results&#39;

        self.eigenvectors,self._clustering_,self._dynamics_ = self._execute_all(
            TR=TR,
            random_state=random_state,
            paired_tests=paired_tests,
            n_perm=n_perm,
            save_results=save_results,
            )

        self.predictions = self._clustering_.predictions
        self._classes_lst_ = np.unique(self.eigenvectors.condition).tolist()
        self._N_classes_ = len(self._classes_lst_)
        self._is_fitted = True

    def _execute_all(self,TR=None,random_state=None,paired_tests=False,n_perm=5_000,save_results=True):
        &#34;&#34;&#34;
        Perform all the steps of the LEiDA (for each subject
        and group/condition/session):

        1) Compute neccesary data:
            a) Computes the instantaneous phase of each
            signal at each time point.
            b) Computes the phase-coherence or PL matrices
            from the previously computed signals phases.
            c) Extracts the leading eigenvector from each
            phase-coherence matrix at time t.

        2) Compute dynamics metrics for each K.
        3) Performs statistical analysis of occupancies and
        dwell times of each PL pattern and for each K partition.

        Params:
        -------
        TR : None | np.float or int. Default = None.
            Specify the Repetition Time of the fMRI data.
            If None, the Dwell times express the mean
            lifetime duration of each PL state in volumes.

        random_state : None or int.
            Determines random number generation for centroid
            initialization. Use an int to make the randomness
            deterministic.

        paired_tests : bool. Default: False.
            Specify if groups are independent or related/paired,
            to run the correct statistical tests.

        n_perm : int. Default = 5000.
            Select number of permutations to apply when running
            the statistical tests.

        save_results : bool. Default = True.
            Whether to save the results on local disk.
        
        Returns: 
        --------
        df_eigens : pd.DataFrame.
            Contains the computed eigenvectors.
            1st column contains subject ids, and
            2nd column the group/condition.

        clustering : dict/bunch.
            Contains the k-means predictions for each
            K partition, the scores of clustering performance,
            and the fitted models.

        dynamics : dict/bunch.
            Contains the computed occupancies, dwell times,
            transitions probabilities and statistical analysis
            results for each K.
        &#34;&#34;&#34;
        subject_ids = list(self.time_series.keys()) #list of subject ids
        N_subjects = len(subject_ids) #number of provided subjects

        #creating folder to save results
        if save_results:
            if os.path.exists(self._results_path_):
                raise Warning(&#34;EXECUTION ABORTED: The folder &#39;LEiDA_results&#39; already &#34;
                            &#34;exists. If you have results from earlier executions of &#34;
                            &#34;the analysis, consider changing the folder&#39;s name or moving &#34;
                            &#34;the folder to another location.&#34;)
            else:
                try:
                    print(f&#34;\n-Creating folder to save results: &#39;./{self._results_path_}&#39;&#34;)
                    os.makedirs(self._results_path_)
                except:
                    raise Exception(&#34;The folder to save the results could&#39;t be created.&#34;)

        #creating variables to save results    
        eigens = []
        sub_list, class_list = [], []

        #Starting process
        print(&#34;\n-STARTING THE PROCESS:\n&#34;
            &#34;========================\n&#34;
            f&#34;-Number of subjects: {N_subjects}&#34;)
            
        print(&#34;\n 1) EXTRACTING THE EIGENVECTORS.\n&#34;)

        for sub_idx,sub_id in enumerate(subject_ids): #for each subject
            #get current subject signals
            tseries = self.time_series[sub_id]
            N_volumes = tseries.shape[1]-2

            print(f&#34;SUBJECT ID: {sub_id} ({tseries.shape[1]} volumes)&#34;)
            
            #Extract the eigenvectors from each phase-coherence matrix at time t.
            eigens.append(
                get_eigenvectors(phase_coherence(hilbert_phase(tseries)))
                )

            #Append metadata to lists (to complete the eigenvectors dataset)
            for volume in range(N_volumes):
                sub_list.append(sub_id)
                if len(self.classes[sub_id])&gt;1:
                    class_list.append(self.classes[sub_id][volume+1])
                else:
                    class_list.append(self.classes[sub_id][0])
        
        # creating dataframe with the extracted eigenvectors
        # and metadata (subjects ids and conditions)
        df_eigens = pd.DataFrame(np.vstack(eigens),columns=self.rois_labels)
        df_eigens.insert(0,&#39;subject_id&#39;,sub_list)
        df_eigens.insert(1,&#39;condition&#39;,class_list)
        
        #saving results
        if save_results:
            try:
                df_eigens.to_csv(f&#39;{self._results_path_}/eigenvectors.csv&#39;,sep=&#39;\t&#39;,index=False)
            except:
                print(&#34;Warning: An error ocurred when saving the &#39;eigenvectors.csv&#39; file to local folder.&#34;)
        
        #clustering
        print(&#34;\n 2) RUNNING K-MEANS CLUSTERING ON EIGENVECTORS.&#34;)
        predictions,clustering_performance,models = identify_states(
            df_eigens,
            K_min=self._K_min_,
            K_max=self._K_max_,
            random_state=random_state,
            save_results=save_results,
            path=self._results_path_ if save_results else None
            )


        #computing dynamical systems theory metrics for each K
        print(&#34;\n 3) COMPUTING THE DYNAMICAL SYSTEMS THEORY METRICS FOR EACH K.&#34;)
        dynamics_data = compute_dynamics_metrics(
            predictions,
            TR=TR,
            save_results=save_results,
            path=self._results_path_ if save_results else None
            )

        #Statistical analysis of occupancies and dwell times for each k
        print(&#34;\n 4) EXECUTING THE STATISTICAL ANALYSIS OF &#34;
            &#34;OCCUPANCIES AND DWELL TIMES FOR EACH K.&#34;)
        stats = _compute_stats(
            dynamics_data,
            paired_tests=paired_tests,
            n_perm=n_perm,
            save_results=save_results,
            path=self._results_path_ if save_results else None
            )

        #Plotting statistical analyses results
        # (scatter plots and barplots&#39; pyramid)
        print(&#34;\n-Creating figures with the statistical analyses results for dwell times &#34;
            &#34;and fractional occupancies. This may take some time. Please wait...&#34;)

        classes = np.unique(df_eigens.condition)

        for metric in [&#39;occupancies&#39;,&#39;dwell_times&#39;]:
            pooled_stats = pd.concat((stats[metric]),ignore_index=True)

            for conditions in combinations(classes,2):
                pooled_stats_ = pooled_stats[
                    (pooled_stats.group_1.isin(conditions))
                    &amp;
                    (pooled_stats.group_2.isin(conditions))
                    ].reset_index(drop=True)

                #plot pyramid
                dyn_data = {k:v[v.condition.isin(conditions)] for k,v in dynamics_data[metric].items()}
                plot_pyramid(
                    dyn_data,
                    pooled_stats_,
                    K_min=self._K_min_,
                    K_max=self._K_max_,
                    metric_name=metric,
                    despine=True
                    )
                if save_results:
                    plt.savefig(f&#39;{self._results_path_}/dynamics_metrics/{conditions[0]}_vs_{conditions[-1]}_{metric}_barplot_pyramid.png&#39;,dpi=300)

                #plot p-values scatter plot
                scatter_pvalues(pooled_stats_,metric=metric,fill_areas=True)
                if save_results:
                    plt.savefig(f&#39;{self._results_path_}/dynamics_metrics/{conditions[0]}_vs_{conditions[-1]}_{metric}_scatter_pvalues.png&#39;,dpi=300)

        #Preparing output
        clustering = Bunch(
            predictions =  predictions,
            performance = clustering_performance,
            models = models
            )

        dynamics = Bunch(
                dwell_times = dynamics_data[&#39;dwell_times&#39;],
                occupancies = dynamics_data[&#39;occupancies&#39;],
                transitions = dynamics_data[&#39;transitions&#39;],
                stats = stats
            )

        print(&#34;\n** THE ANALYSIS HAS FINISHED SUCCESFULLY!&#34;)
        if save_results:
            print(f&#34;-All the results were save in &#39;./{self._results_path_}&#39;&#34;)

        print(&#34;\n-You can explore the results in detail by using &#34;
            &#34;the methods and attributes of the Leida class.&#34;)
        
        #output
        return df_eigens,clustering,dynamics

    def load_model(self,k=2):
        &#34;&#34;&#34;
        Load fitted model for a specific &#39;k&#39; partition.
        Given that each model is an instance of the KMeansLeida
        class, once loaded you can access all the object methods
        and attributes.

        Params:
        -------
        k : int.
            Select the partition of interest.
        
        Returns:
        -------
        model : KMeansLeida instance.
            The fitted model that was used to predict
            the cluster labels of each observation.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        model = self._clustering_.models[f&#39;k_{k}&#39;]
        return model

    def load_centroids(self,k=2):
        &#34;&#34;&#34;
        Return the computed clusters centroids
        for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the partition of interest.
        
        Returns:
        -------
        centroids : pd.DataFrame with shape (n_centroids,n_rois).
            Contains the computed centroids for
            the selected k partition.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        centroids = pd.DataFrame(self.load_model(k=k).cluster_centers_,columns=self.rois_labels)
        return centroids

    def centroids_distances(self,k=2):
        &#34;&#34;&#34;
        Transform eigenvectors to a cluster-distance space. 
        Returns the distance between each eigenvector and the
        cluster centroids of the selected &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the partition of interest.
        
        Returns:
        --------
        distances : pd.DataFrame.
            Contains the distace between each eigenvector and
            each cluster centroid for the select &#39;k&#39; partition.
            1st column contains &#39;subject_id&#39;, 2nd column the
            &#39;condition&#39;, and the rest of columns the distances
            to the centroids.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)

        model = self.load_model(k=k)
        distances = pd.DataFrame(model.transform(self.eigenvectors.iloc[:,2:].values))
        distances.columns = [f&#39;centroid_{centroid+1}&#39; for centroid in range(k)]
        distances = pd.concat((self.eigenvectors[[&#39;subject_id&#39;,&#39;condition&#39;]],distances),axis=1)
        return distances

    def stats(self,k=2,metric=&#39;occupancies&#39;):
        &#34;&#34;&#34;
        Retrieve the results from the statistical analysis of 
        a &#39;metric&#39; of interest (&#39;occupancies&#39; or &#39;dwell_times&#39;)
        for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the &#39;k&#39; partition of interest.

        metric : str.
            Select the metric to retrieve results.

        Returns:
        --------
        stats : pandas.dataframe.
            Results of the statistical analysis
            of each PL state.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_metric(metric)

        df_stats = self._dynamics_.stats[metric][f&#39;k_{k}&#39;]
        return df_stats

    def dwell_times(self,k=2):
        &#34;&#34;&#34;
        Return the computed dwell times of each
        phase-locking state for a specific &#39;k&#39;
        partition.

        Params:
        -------
        k : int.
            Specify the K-Means partition of interest.

        Returns:
        --------
        dwell_times : pd.DataFrame.
            Contains the computed dwell times of each
            PL state for each subject for the selected
            &#39;k&#39; partition.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        return self._dynamics_.dwell_times[f&#39;k_{k}&#39;]

    def transitions(self,k=2):
        &#34;&#34;&#34;
        Return the computed transition probabilities between
        phase-locking states for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Specify the K-Means partition of interest.

        Returns:
        --------
        transitions : pd.DataFrame.
            Contains the computed transition probabilities
            between PL states for each subject for the selected
            &#39;k&#39; partition.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        return self._dynamics_.transitions[f&#39;k_{k}&#39;]

    def occupancies(self,k=2):
        &#34;&#34;&#34;
        Return the computed fractional occupancy of each
        phase-locking state for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Specify the K-Means partition of
            interest.

        Returns:
        --------
        occupancies : pd.DataFrame.
            Contains the computed fractional occupancy
            of each PL state for each subject for the
            selected &#39;k&#39; partition.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        return self._dynamics_.occupancies[f&#39;k_{k}&#39;]

    def significant_states(self,metric=&#34;occupancies&#34;):
        &#34;&#34;&#34;
        Return a dataframe containing only the statistics
        of the phase-locking states that are significantly
        different between groups.

        Params:
        -------
        metric : str.
            Metric of interest (Options: &#39;occupancies&#39;,
            &#39;dwell_times&#39;).

        Returns:
        --------
        stats : pandas.dataframe.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_metric(metric)

        stats = self._pool_stats(metric=metric)
        has_results = True if stats[stats.reject_null==True].shape[0]&gt;=1 else False #check if some result was significant
        if has_results:
            return stats[stats.reject_null==True]
        else:
            print(&#34;No significant results were founded.&#34;)
            return None

    def state_rois(self,k=2,state=1):
        &#34;&#34;&#34;
        Get a list with the names of the ROIs/parcels that
        participates in a specific phase-locking (PL) state.

        Params:
        -------
        k : int.
            Select the partition.

        state : int.
            Select the PL pattern or state of
            interest.

        Returns:
        --------
        rois : list.
            Contains the names of the ROIs that
            are part of the selected PL state.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        data_k = self.load_centroids(k=k).iloc[state-1,:].reset_index()
        data_k.columns = [&#39;rois&#39;,&#39;value&#39;]
        rois = list(data_k[data_k.value&gt;0][&#39;rois&#39;])
        return rois

    def group_static_fc(self,group=None,plot=True,cmap=&#39;jet&#39;,darkstyle=False):
        &#34;&#34;&#34;
        Compute the mean static functional
        connectivity matrix of a particular
        group/condition.

        Params:
        --------
        group : str.
            Specify the group of interest.

        plot : bool.
            Whether to create a heatmap showing
            the connectivity matrix.

        cmap : str.
            If plot=True, then select the colormap
            to use for the heatmap. Default = &#39;jet&#39;.

        darkstyle : bool.
            Whether to use a dark background
            for plotting.

        Returns:
        --------
        static_fc : ndarray with shape (N_ROIs, N_ROIs).
            The computed static functional connectivity
            matrix.
        &#34;&#34;&#34;
        if not isinstance(group,str):
            raise TypeError(&#34;&#39;group&#39; must be a string.&#34;)

        #create list with conditions labels
        conditions = []
        for val in self.classes.values():
            for item in val:
                conditions.append(item)

        if len(conditions) != len(self.time_series.keys()):
            raise Exception(&#34;This method is only available in &#34;
                &#34;cases where each subject has only one condition label.&#34;)
        if group not in conditions:
            raise ValueError(&#34;&#39;group&#39; must be present in your data. &#34;
                f&#34;Possible options are: {[i for i in np.unique(conditions)]}.&#34;)       

        subjects_ids = [sub for sub,condition in zip(self.time_series.keys(),conditions) if condition==group]
        N_subjects = len(subjects_ids)
        N_rois = len(self.rois_labels)
        pooled_static_fc = np.empty((N_rois,N_rois,N_subjects))
        
        for idx,sub in enumerate(subjects_ids):
            pooled_static_fc[:,:,idx] = np.corrcoef(self.time_series[sub])
        
        static_fc = np.mean(pooled_static_fc,axis=-1)

        if plot:
            plt.ion()
            with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
                plt.figure()
                sns.heatmap(
                    static_fc,
                    vmin=-1,
                    vmax=1,
                    center=0,
                    square=True,
                    cmap=cmap,
                    cbar_kws={&#39;label&#39;: &#39;Pearson\ncorrelation&#39;,&#39;shrink&#39;: 0.5}
                )

                plt.xlabel(&#39;Brain region&#39;,fontsize=16,labelpad=20)
                plt.ylabel(&#39;Brain region&#39;,fontsize=16,labelpad=20)
                plt.title(group)
                plt.xticks(
                        np.arange(20,N_rois,20),
                        np.arange(20,N_rois,20).tolist(),
                        rotation=0
                        )
                plt.yticks(
                        np.arange(20,N_rois,20),
                        np.arange(20,N_rois,20).tolist()
                        )
                plt.tick_params(
                    axis=&#39;both&#39;,         
                    which=&#39;both&#39;,     
                    bottom=False,
                    left=False
                    )
                plt.tight_layout()
                #plt.show()

        return static_fc

    def group_transitions(self,k=2,metric=&#39;mean&#39;,cmap=&#39;inferno&#39;,darkstyle=False):
        &#34;&#34;&#34;
        Compute and plot the mean or median transition
        probabilities matrix of each group/condition.

        Params:
        -------
        k : int.
            The k-means partition of interest.

        metric : str.
            Whether to plot the &#39;mean&#39; or &#39;median&#39;
            matrices.

        cmap : str.
            Colormap to use in the created heatmaps.

        darkstyle : bool.
            Whether to use a dark background for
            plotting.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        mats = group_transition_matrix(
            self._dynamics_.transitions[f&#39;k_{k}&#39;],
            metric=metric,
            cmap=cmap,
            darkstyle=darkstyle
            )

        return mats

    def overlap_withyeo(self,parcellation=None,n_areas=None,k=2,state=None,darkstyle=False):
        &#34;&#34;&#34;
        Compute the overlap between the 7 resting-state
        networks defined in Yeo et al. (2011) and the brain
        cortical regions/parcels of the phase-locking state
        of interest. The correlations are shown in a barplot,
        and a dataframe with the correlations and p-values is
        returned.

        Params:
        --------
        parcellation : str.
            Specify path to your parcellation .nii file.
            Note: the parcellation must be of 2mm resolution.

        n_areas : None | int.
            Analyze only the first n areas from the provided
            parcellation. 
            Usefull when the parcellation contains subcortical
            regions that must be ignored when computing the overlap
            with Yeo&#39;s cortical networks.

        k : int.
            Select the partition.

        state : int.
            Select the PL pattern or state of
            interest.

        darkstyle : bool.
            Whether to use a dark theme for the plot.

        Returns:
        --------
        overlap : pandas.dataframe with shape (7networks,3).
            Contains the correlation coefficient (and p-value)
            between the selected phase-locking state and each
            of the 7 resting-state networks from Yeo (2011).
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        centr = {}

        for k_ in range(self._K_min_,self._K_max_+1):
            cent = self.load_centroids(k_)
            cent.insert(0,&#39;state&#39;,[i+1 for i in range(cent.shape[0])])
            cent.insert(0,&#39;k&#39;,k_)
            centr[f&#39;k{k_}&#39;] = cent
        
        centr = pd.concat(centr,ignore_index=True)

        corr,pvals = rsnets.compute_overlap(
            centr,
            parcellation=parcellation,
            n_areas=n_areas
            )

        overlap = rsnets.state_overlap(
            corr,
            pvals,
            k=k,
            state=state,
            plot=True,
            darkstyle=darkstyle
            )

        return overlap

    def _pool_stats(self,metric=&#34;occupancies&#34;):
        &#34;&#34;&#34;
        Pool the stats for each k for the selected
        metric in a single dataframe.

        Params:
        --------
        metric : str.
            Specify the metric of interest
            (&#39;occupancies&#39;,&#39;dwell_times&#39;,&#39;transitions&#39;).
        &#34;&#34;&#34;
        self._check_is_fitted()

        data = {}
        for k in np.arange(self._K_min_,self._K_max_+1):
            data[k] = self.stats(k=int(k),metric=metric)
        data = pd.concat((data),ignore_index=True)
        return data

    #Parameters validation

    def _validate_constructor_params(self):
        &#34;&#34;&#34;Validate input data provided in &#39;path&#39;.&#34;&#34;&#34;
        
        #1.validate time series.
        #check whether all the subjects have
        #the same number of brain regions
        nrois = [self.time_series[sub].shape[0] for sub in self.time_series.keys()]
        if np.unique(nrois).size&gt;1:
            raise Exception(&#34;The number of brain regions must be &#34;
                            &#34;the same for all the subjects.&#34;)

        #check that the number of ROIs labels
        #coincide with the number of ROIs in time series
        if np.unique(nrois).item()!=len(self.rois_labels):
            raise Exception(f&#34;The number of brain regions in time series ({np.unique(nrois).item()}) must &#34;
                            f&#34;coincide with the number of ROIs labels ({len(self.rois_labels)}).&#34;)

        #2.validate metadata (labels info).
        #check if the number of subjects in &#39;time_series&#39; 
        #and &#39;classes&#39; dictionaries coincide.
        nsub_signals = len(self.time_series.keys())
        nsub_classes = len(self.classes.keys())
        if nsub_signals != nsub_classes:
            raise Exception(f&#34;The number of subjects in &#39;time_series&#39; (n={nsub_signals}) &#34;
                            f&#34;and&#39;metadata&#39; (n={nsub_classes}) must be equal.&#34;)
        #check if each subject in &#39;time_series&#39; has his corresponding metadata.
        elif bool(set(self.time_series.keys())-set(self.classes.keys())):
            raise Exception(f&#34;The metadata of the following subject/s was not founded:\n &#34;
                            f&#34;{set(self.time_series.keys())-set(self.classes.keys())}&#34;)
        #check if the number of labels match with the number of volumes.
        else:
            n_labels = [len(self.classes[sub]) for sub in self.classes.keys()] #get n of labels per subject
            if np.max(n_labels)!=1:
                labels_info = list()
                for sub in self.time_series.keys():
                    labels_info.append(
                        {&#39;subject_id&#39;:sub,
                        &#39;n_volumes&#39;:self.time_series[sub].shape[1],
                        &#39;n_labels&#39;:len(self.classes[sub])}
                    )
                labels_info = pd.DataFrame(labels_info)
                
                mismatchs_ids = labels_info[~(labels_info[&#39;n_volumes&#39;] == labels_info[&#39;n_labels&#39;])].subject_id.tolist()

                if bool(mismatchs_ids):
                    print(labels_info[labels_info.subject_id.isin(mismatchs_ids)])
                    raise Exception(&#34;Some subject/s have a different number of &#34;
                                    &#34;volumes and labels!&#34;)
        
            #check if more than 1 condition is present in &#39;metadata&#39;
            conditions = []
            for val in self.classes.values():
                for item in val:
                    conditions.append(item)
            if np.unique(conditions).size==1:
                raise Exception(&#34;The number of conditions must be at least 2!&#34;)

        #3.validate rois coordinates
        if self.rois_coordinates is None:
            print(&#34;The ROIs coordinates couldn&#39;t be loaded from the provided &#39;data_path&#39;. &#34;
                &#34;Brain plots that show nodes in brain space will not be executed in consequence.&#34;)
        else:
            #check if the number of roi labels match 
            #with the number of MNI coordinates.
            if len(self.rois_labels) != self.rois_coordinates.shape[0]:
                raise Exception(f&#34;The number of &#39;ROIs labels&#39; ({len(self.rois_labels)} were provided) &#34;
                    f&#34;must coincide with the number of provided coordinates ({self.rois_coordinates.shape[0]} were provided)&#34;)

        print(&#34;All the data has been sucesfully loaded.&#34;)

    def _check_is_fitted(self):
        &#34;&#34;&#34;
        Check if the k-means models had been already fitted.
        &#34;&#34;&#34;
        if not hasattr(self,&#34;_is_fitted&#34;):
            raise Exception(&#34;You have to fit the models first by using the &#39;fit_predict&#39; method.&#34;)

    #Plotting methods

    def plot_clusters3D(self,k=2,clusters_colors=None,grid=True,alpha=.7,dot_size=3,edgecolor=None,darkstyle=False):
        &#34;&#34;&#34;
        Visualize the identified clusters (BOLD phase-locking
        states) in a 3D scatter plot, which constitutes a
        low-dimensional representation of the &#39;state space&#39;. 
        Method : take the eigenvectors and extract the first
        three principal components to reduce the dimensionality
        of the data to a 3D space. Each dot in the plot thus
        represents a single eigenvector, and is coloured according
        to the cluster it belongs to.
        
        Params:
        -------
        k : int.
            Specify the partition to plot.

        clusters_colors : list (optional). 
            Provide a list with the desired color
            of each cluster. If not provided, then
            a predefined set of colors will be used.

        grid : bool. 
            Whether to show grid or not.

        alpha : float. 
            Set transparency of dots.

        dot_size : float. 
            Select the dot size.

        edge_color : None | str.
            Specify an edge color to use
            on dots.

        darkstyle : bool.
            Whether to use a dark theme for
            the plot.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        X = np.array(self.eigenvectors.iloc[:,2:], dtype=np.float32) #keep array containing only the eigenvectors
        y = self._clustering_.predictions[f&#39;k_{k}&#39;].values #keep 1D array with the labels of each eigenvector

        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            plot_clusters3D(
                X,
                y,
                clusters_colors=clusters_colors,
                grid=grid,
                alpha=alpha,
                dot_size=dot_size,
                edgecolor=edgecolor
                )

    def plot_voronoi_cells(self,k=2):
        &#34;&#34;&#34;
        Plot the clusters centroids in a 2D Voronoi
        cells space. Performs a PCA to reduce the
        dimensionality of the original centroid space
        to a 2D space.

        Params:
        --------
        k : int.
            Select the clustering solution to plot.

        Note: see Vohryzek, Deco et al. (2020) p.4
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        centroids = self.load_centroids(k=k).values 
        plot_voronoi(centroids)

    def plot_pvalues(self,metric=&#39;occupancies&#39;,conditions=None,darkstyle=False,fill_areas=True):
        &#34;&#34;&#34;
        Create a scatter plot showing the p-values
        obtained by the statistical analysis of a given
        &#39;metric&#39; across the explored &#39;k&#39; range.

        Params:
        -------
        metric : str. 
            Specify the metric of interest
            (&#39;occupancies&#39;,&#39;dwell_times&#39;,&#39;transitions&#39;).

        conditions : None | list. Optional
            (Usefull only when your data contains more
            than two conditions). You can provide a list
            specifying only two conditions of interest to
            plot. Otherwise create a plot for each pair of
            conditions. 

        darkstyle : bool.
            Whether to use a dark theme for
            the plots.

        fill_areas : bool.
            Select whether to fill the significance
            areas with color.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_metric(metric)

        if not isinstance(fill_areas,bool) or not isinstance(darkstyle,bool):
            raise TypeError(&#34;&#39;fill_areas&#39; and &#39;darkstyle&#39; must be True or False!&#34;)

        if conditions is not None:
            if not isinstance(conditions,list) or len(conditions)!=2:
                raise Exception(&#34;If provided, &#39;conditions&#39; must be a list with two items.&#34;)
            for cond in conditions:
                if cond not in self._classes_lst_:
                    raise Exception(f&#34;&#39;{cond}&#39; was not founded in the data. &#34;
                                    f&#34; Valid options are: {self._classes_lst_}&#34;)
        else:
            conditions = self._classes_lst_.copy()

        pooled_stats = self._pool_stats(metric=metric)

        for cond in combinations(conditions,2):
            pooled_stats_ = pooled_stats[
                    (pooled_stats.group_1.isin(cond))
                    &amp;
                    (pooled_stats.group_2.isin(cond))
                    ].reset_index(drop=True)

            scatter_pvalues(pooled_stats_,metric=metric,darkstyle=darkstyle,fill_areas=fill_areas)

    def plot_states_nodes(self,k=2,state=1,node_size=15,show_labels=True,open=True,save=False):
        &#34;&#34;&#34;
        Create a 3D interactive figure embedded in a
        .html file showing the BOLD phase-locking (PL)
        states in anatomical MNI space. Each parcel/ROI
        is represented as a node. Nodes that are part of
        the PL pattern are coloured in red, and the rest
        of nodes are coloured in blue.

        Params:
        -------
        k : int.
            Select the partition of interest.

        state : int or str.
            Use an integer to plot a single
            PL state of interest, or &#39;all&#39;
            to plot all the PL states of the
            selected K partition.

        node_size: int or float.
            Define the size of the nodes. Nodes
            that don&#39;t belong to the pattern are
            plotted smaller.

        show_labels : bool.
            Whether to show each ROI label.

        open : bool. 
            Whether to open the plots in web
            browser. If False, you can open the
            figures using the &#39;.open_in_browser()&#39;
            method of the returned object/s.

        save : bool.
            Whether to save each plot in a
            .html file. If True, the files
            are saved in &#39;LEiDA_results/brain_plots&#39;.

        Returns:
        --------
        plot/s : dict or single figure.
            If state=&#39;all&#39;, return a dictionary
            that contains the constructed plots.
            They can be opened or saved using
            &#39;.open()&#39; and &#39;.save_as_html(path)&#39;,
            respectively. If state=int, then return
            a single figure.
        &#34;&#34;&#34;
        self._check_is_fitted()
        if self.rois_coordinates is None:
            raise Exception(&#34;You can&#39;t create this plot because the &#34;
                            &#34;ROI&#39;s coordinates could&#39;t be loaded.&#34;)

        _check_k_input(self._K_min_,self._K_max_,k)
        centroids = self.load_centroids(k=k).values
        plots = brain_states_nodes(
            centroids,
            self.rois_coordinates,
            node_size=node_size,
            state=state,
            nodes_labels=None if not show_labels else self.rois_labels,
            open=open
            )

        if save:
            _save_html(self._results_path_,plots,k,state,plot_type=&#39;nodes&#39;)

        return plots

    def plot_states_network(self,k=2,state=1,node_size=8,node_color=&#39;infer&#39;,linewidth=3,open=True,save=False):
        &#34;&#34;&#34;
        Create a 3D interactive figure embedded in a
        .html file showing the BOLD phase-locking (PL)
        states as a connected network. All the ROIs/parcels
        that belong to the selected phase-locking state are
        connected between each other.

        Params:
        -------
        k : int.
            Select the partition of interest.

        state : int or str.
            Use an integer to plot a single
            PL state of interest, or &#39;all&#39;
            to plot all the PL states of the
            selected K partition.

        node_size : int. 
            Select the size of the nodes.

        node_color : str. 
            Select the color of the nodes. If
            &#39;infer&#39;, then the nodes participating
            in the PL states are colored red and
            the rest blue. If &#39;black&#39;, then all the
            nodes are colored in the same way.

        linewidth : int. 
            Select the size of the edges
            connecting the nodes.

        open : bool. 
            Whether to open the plots in web
            browser. If False, you can open the
            figures using the &#39;.open_in_browser()&#39;
            method of the returned object/s.

        save : bool.
            Whether to save each plot in a
            .html file. If True, the files
            are saved in &#39;LEiDA_results/brain_plots&#39;.

        Returns:
        --------
        plot/s : dict or single figure.
            If state=&#39;all&#39;, return a dictionary
            that contains the constructed plots.
            They can be opened or saved using
            &#39;.open()&#39; and &#39;.save_as_html(path)&#39;,
            respectively. If state=int, then return
            a single figure.
        &#34;&#34;&#34;
        if self.rois_coordinates is None:
            raise Exception(&#34;You can&#39;t create this plot because the &#34;
                            &#34;ROI&#39;s coordinates could&#39;t be loaded.&#34;)
        
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        if not isinstance(state,(int,str)):
            raise TypeError(&#34;&#39;state&#39; must be either &#39;all&#39; or an integer &#34;
                            &#34;specifying the number of a particular PL state.&#34;)
        if isinstance(state,str):
            if state!=&#39;all&#39;:
                raise ValueError(&#34;If a string is provided, &#39;state&#39; must be &#39;all&#39;!&#34;)
        else:
            _check_state(k,state)

        centroids = self.load_centroids(k=k).values #load centroids for the selected k

        #plotting
        plot = brain_states_network(
            centroids,
            self.rois_coordinates,
            state=state,
            node_size=node_size,
            node_color=node_color,
            linewidth=linewidth,
            open=open,
            )

        #saving figures
        if save:
            _save_html(self._results_path_,plot,k,state,plot_type=&#39;network&#39;)
            
        return plot

    def plot_states_in_bold(self,subject_id,k=2,alpha=.5,darkstyle=False):
        &#34;&#34;&#34;
        Create plot showing the time-series of BOLD signals, 
        highlighting the dominant phase-locking (PL) state
        of each time point or volume.

        Params:
        -------
        subject_id : str.
            Specify the &#39;id&#39; of the subject
            of interest.

        k : int.
            Select the k partition.

        alpha : float.
            Transparency of the colors that
            show the dominant PL pattern of
            each time point.

        darkstyle : bool.
            Whether to create the plot using
            a darkstyle.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        tseries = self.time_series[subject_id][:,1:-1] #get subject signals (excluding the 1st and last volumes)
        predictions = self._clustering_.predictions
        y = predictions[predictions.subject_id==subject_id][f&#39;k_{k}&#39;].values #get predictions for selected k.

        with plt.style.context(&#34;dark_background&#34; if darkstyle else &#34;default&#34;):
            states_in_bold(tseries,y,alpha=alpha)

    def plot_states_pyramid(self,metric=&#39;occupancies&#39;,conditions=None,despine=True):
        &#34;&#34;&#34;
        Create a pyramid of barplots showing the &#39;metric&#39;
        of interest for each group, cluster (PL state), and
        K partition. Each barplot (which represents a particular
        PL state) is coloured according to its associated p-value:
        -black: the p-value is higher than 0.05.
        -red: the p-value is lower than 0.05 but higher than 0.05 / k.
        -green: the p-value is lower than 0.05/k but higher than 0.05 / (k).
        -blue: the p-value is lower than 0.05 / (k).

        Params:
        -------
        metric : str.
            Select the dynamical systems theory metric
            of interest (either &#39;occupancies&#39; or &#39;dwell_times&#39;).

        conditions : None | list. Optional.
            (Usefull only when your data contains more
            than two conditions). You can provide a list
            specifying only two conditions of interest to
            plot. Otherwise create a plot for each pair of
            conditions. 

        despine : bool. Default = True.
            Whether to despine top and right axes of the
            subplots.
        &#34;&#34;&#34;
        self._check_is_fitted
        _check_metric(metric)

        if conditions is not None:
            if not isinstance(conditions,list) or len(conditions)!=2:
                raise Exception(&#34;If provided, &#39;conditions&#39; must be a list with two items.&#34;)
            for cond in conditions:
                if cond not in self._classes_lst_:
                    raise Exception(f&#34;&#39;{cond}&#39; was not founded in the data. &#34;
                                    f&#34; Valid options are: {self._classes_lst_}&#34;)
        else:
            conditions = self._classes_lst_.copy()

        pooled_stats = self._pool_stats(metric=metric)

        for cond in combinations(conditions,2):
            pooled_stats_ = pooled_stats[
                    (pooled_stats.group_1.isin(cond))
                    &amp;
                    (pooled_stats.group_2.isin(cond))
                    ].reset_index(drop=True)

            dyn_metric = self._dynamics_[metric]
            dyn_metric = {k:v[v.condition.isin(conditions)] for k,v in dyn_metric.items()}

            plot_pyramid(
                dyn_metric,
                pooled_stats_,
                K_min=self._K_min_,
                K_max=self._K_max_,
                despine=despine
                )

    def barplot_centroids(self,k=2,state=&#39;all&#39;):
        &#34;&#34;&#34;
        Create either subplots with barplots showing the
        values of each cluster centroid for the selected &#39;k&#39;
        partition, or a single barplot showing the values
        of a specific phase-locking state.

        Params:
        ------
        k : int.
            Select the partition of interest.

        state : str or int.
            Specify if plot all the states for
            the selected &#39;k&#39;, or a single state
            of interest.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        centroids = np.array(self.load_centroids(k=k),dtype=np.float32) #get centroids of the selected &#39;k&#39;.
        if state==&#39;all&#39;:
            barplot_states(centroids,self.rois_labels)
        else:
            _check_state(k,state)
            barplot_eig(centroids[state-1,:],self.rois_labels)
            plt.title(f&#39;PL pattern {state}&#39;,fontsize=18,pad=15)
            plt.tight_layout()

    def plot_clustering_performance(self):
        &#34;&#34;&#34;
        Create a 2x2 panel with lineplots showing
        the clustering evaluation metrics for each
        k partition explored (Dunn score, distortion,
        silhouette score, and Davis-Bouldin score).
        &#34;&#34;&#34;
        self._check_is_fitted()
        plot_clustering_scores(self._clustering_.performance)

    def plot_states_network_glass(self,k=2,darkstyle=False):
        &#34;&#34;&#34;
        Create a glass brain (axial view) showing the
        network representation of each phase-locking
        (PL) state for the selected &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the partition of interest.

        darkstyle : bool.
            Whether to use a dark theme for
            the plots.
        &#34;&#34;&#34;
        if self.rois_coordinates is None:
            raise Exception(&#34;You can&#39;t create this plot because the ROI&#39;s coordinates could&#39;t be loaded.&#34;)

        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        pl_states = self.load_centroids(k=k).values

        with plt.style.context(&#34;dark_background&#34; if darkstyle else &#34;default&#34;):
            states_k_glass(pl_states,self.rois_coordinates,darkstyle=darkstyle)

    def plot_states_on_surf(self,k=2,state=&#39;all&#39;,parcellation=None,discretize=True,cmap=&#39;auto&#39;,darkstyle=False,open=False,save=False):
        &#34;&#34;&#34;
        Create a 3D interactive figure embedded in a
        .html file showing the BOLD phase-locking (PL)
        states on cortical surface. By default, all the
        cortical regions that belong to a given PL state
        or pattern are coloured in red(s), while the rest
        of cortical regions are coloured in blue(s). You
        can change the colormap throught the &#39;cmap&#39; argument.

        Params:
        -------
        k : int.
            Partition of interest.

        state : str or int.
            Whether to plot &#39;all&#39; the PL states of
            the selected partition or a single state
            of interest.

        parcellation : str.
            Path to the .nii file containing the
            parcellation from which the time series
            were extracted.

        discretize : bool. Default = True.
            Whether to plot the raw values of the
            phase-locking state/centroid, or plot
            all the brain regions that belong to
            the phase-locking state with the same
            intensity.

        cmap : str or matplotlib colormap, optional. Default = &#39;auto&#39;.
            Colormap to use in the brain plot.
            If &#39;auto&#39;, then the brain regions that
            belong to the phase-locking state will
            be coloured in red(s), and the rest of
            regions in blue(s).

        darkstyle : bool.
            Whether to use a black background.

        open : bool. 
            Whether to open the plots in web
            browser. If False, you can open the
            figures using the &#39;.open_in_browser()&#39;
            method of the returned object/s.

        save : bool.
            Whether to save each plot in a
            .html file. If True, the files
            are saved in &#39;LEiDA_results/brain_plots&#39;.

        Returns:
        --------
        g : SurfaceView or dictionarity of SurfaceViews. 
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        if not isinstance(state,(int,str)):
            raise TypeError(&#34;&#39;state&#39; must be either &#39;all&#39; or an integer &#34;
                            &#34;specifying the number of a particular PL state&#34;)
        if isinstance(state,str):
            if state!=&#39;all&#39;:
                raise ValueError(&#34;If a string is provided, &#39;state&#39; must be &#39;all&#39;!&#34;)
        else:
            _check_state(k,state)

        centroids = self.load_centroids(k=k).values 
        if state!=&#39;all&#39;:
            centroids = centroids[state-1,:]
        
        g = brain_states_on_surf(
            centroids,
            parcellation=parcellation,
            black_bg=darkstyle,
            open=open,
            discretize=discretize,
            cmap=cmap
            )

        if save:
            _save_html(self._results_path_,g,k,state,plot_type=&#39;surface&#39;)

        return g

    def plot_states_on_surf2(self,k=2,state=1,parcellation=None,surface=&#39;pial&#39;,hemi=&#39;right&#39;,view=&#39;lateral&#39;,darkstyle=False,save=False):
        &#34;&#34;&#34;
        Plot a BOLD phase-locking state of interest 
        on cortical surface mesh. 

        Params:
        -------
        k : int.
            Partition of interest.

        state : int.
            Select the PL state/pattern of
            interest.

        parcellation : str.
            Path to the .nii file containing
            the parcellation from which the
            signals were extracted.

        surface : str.
            Specify the surface type to plot
            the pattern on. Valid options are
            &#39;pial&#39;,&#39;infl&#39;, and &#39;white&#39;.

        hemi : str.
            Select the hemisphere to plot.
            Valid options are &#39;right&#39;, &#39;left&#39;,
            or &#39;both&#39;.

        view : str
            View of the surface that is rendered. 
            Default=&#39;lateral&#39;. Options = {&#39;lateral&#39;,
            &#39;medial&#39;, &#39;dorsal&#39;, &#39;ventral&#39;, &#39;anterior&#39;,
            &#39;posterior&#39;}. If &#39;hemi&#39;=&#39;both&#39;, then &#39;dorsal&#39;
            and &#39;lateral&#39; views are displayed.

        darkstyle : bool
            Whether to use a black background.

        save : bool.
            Whether to save the created figure in
            local folder. If True, the files are
            saved in &#39;LEiDA_results/brain_plots&#39;,
            and the plot will not be displayed.

        Returns:
        --------
        g : matplotlib figure. 
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        centroids = self.load_centroids(k=k).values 
        centroid = centroids[state-1,:]

        if save: 
            path = f&#39;{self._results_path_}/brain_plots&#39;
            if not os.path.exists(path): 
                os.makedirs(path)
        #plotting
        print(&#34;\n-Creating plot. This may take &#34;
            &#34;some minutes. Please wait...&#34;)

        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            g = brain_states_on_surf2(
                centroid,
                parcellation=parcellation,
                hemi=hemi,
                surface=surface,
                view=view
                )
        
        if save:
            try:
                filename = f&#34;{path}/K{k}_PL_state_{state}_{surface}surf_{hemi}hemi_{view if hemi!=&#39;both&#39; else &#39;multiview&#39;}{&#39;_dark&#39; if darkstyle else &#39;&#39;}.png&#34;
                g.savefig(filename,dpi=300)
                plt.close()
                del g
                print(f&#34;The plot was save at: {filename}&#34;)
            except:
                raise Exception(&#34;An error occured when saving the plot.&#34;)
        else:
            return g

    def explore_state(self,k=2,state=1,darkstyle=False):
        &#34;&#34;&#34;
        Create a figure showing a phase-locking state of
        interest in different formats:
        a barplot, a network representation in brain space,
        a matrix representation, and two boxplots with the
        occupancies and dwell times for each group/condition.

        Params:
        ------
        k : int.
            Select the partition of interest.

        state : int.
            Select the PL state of interest.

        darkstyle : bool.
            Whether to use a dark background.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        centroid = self.load_centroids(k=k).values
        centroid = centroid[state-1,:]

        occ = self.occupancies(k=k)[[&#39;condition&#39;,f&#39;PL_state_{state}&#39;]]
        dt = self.dwell_times(k=k)[[&#39;condition&#39;,f&#39;PL_state_{state}&#39;]]

        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            _explore_state(
                centroid,
                self.rois_labels,
                occ,
                dt,
                self.rois_coordinates,
                state_number=state,
                darkstyle=darkstyle
                )

    def plot_states_matrices(self,k=2,cmap=&#39;jet&#39;,darkstyle=False):
        &#34;&#34;&#34;
        Take the controids resulting from the k-means
        clustering (i.e., the phase-locking states) and
        reconstruct the connectivity patterns in matrix
        format.

        Params:
        -------
        k : int.
            Specify the K partition of interest.
        
        cmap : str. Default = &#39;jet&#39;.
            Select the colormap to use.

        darkstyle : bool.
            Whether to use a black background.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        if not isinstance(cmap,str):
            raise TypeError(&#34;&#39;cmap&#39; must be a string!&#34;)
        if not isinstance(darkstyle,bool):
            raise TypeError(&#34;&#39;darkstyle&#39; must be True or False!&#34;)

        _ = centroid2matrix(
            self.load_centroids(k).values,
            plot=True,
            cmap=cmap,
            darkstyle=darkstyle
            )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>

<dl>
<dt id="pyleida._leida.Leida"><code class="flex name class">
<span>class <span class="ident">Leida</span></span>
<span>(</span><span>data_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to execute the LEiDA pipeline
and explore the results.</p>
<h2 id="params">Params:</h2>
<p>data_path : str.
Path to the folder that contains the time
series, ROIs labels and coordinates, and
the group/condition of each subject.</p>
<h2 id="attributes">Attributes:</h2>
<p>eigenvectors : pandas.dataframe.
Contains the computed eigenvectors.</p>
<p>predictions : pandas.dataframe.
Contains the predicted cluster label of
each eigenvector for each 'k' partition
explored.</p>
<p>rois_labels : list.
The label/name of each ROI/parcel.</p>
<p>rois_coordinates : ndarray of shape (n_rois,3).
The MNI coordinates of each ROI/parcel.</p>
<p>time_series : dict.
Contains the BOLD signals of each subject.
The keys are the subject id's, and the values
are numpy 2D arrays (N_ROIs, N_volumes) with
the time series of each brain region/parcel.</p>
<p>classes : dict.
Contains the condition/group label/s
of each subject.
Keys are subject id's.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Leida:
    &#34;&#34;&#34;
    Class to execute the LEiDA pipeline
    and explore the results.

    Params:
    -------
    data_path : str.
        Path to the folder that contains the time
        series, ROIs labels and coordinates, and
        the group/condition of each subject.

    Attributes:
    -----------
    eigenvectors : pandas.dataframe.
        Contains the computed eigenvectors.

    predictions : pandas.dataframe.
        Contains the predicted cluster label of
        each eigenvector for each &#39;k&#39; partition
        explored.

    rois_labels : list.
        The label/name of each ROI/parcel.

    rois_coordinates : ndarray of shape (n_rois,3).
        The MNI coordinates of each ROI/parcel.

    time_series : dict.
        Contains the BOLD signals of each subject.
        The keys are the subject id&#39;s, and the values
        are numpy 2D arrays (N_ROIs, N_volumes) with
        the time series of each brain region/parcel.

    classes : dict.
        Contains the condition/group label/s
        of each subject.
        Keys are subject id&#39;s.

    &#34;&#34;&#34;
    def __init__(self,data_path):
        if not isinstance(data_path,str):
            raise TypeError(&#34;&#39;data_path&#39; must be a string!&#34;)
        else:
            if not os.path.exists(data_path):
                raise ValueError(f&#34;The specified path could&#39;t be founded.&#34;)

        self.time_series = load_tseries(data_path)
        self.classes = load_classes(data_path)
        self.rois_labels = load_rois_labels(data_path)
        self.rois_coordinates = load_rois_coordinates(data_path)

        self._validate_constructor_params() #check if the data has been loaded sucessfully.

    def fit_predict(self,TR=None,paired_tests=False,n_perm=5_000,save_results=True,random_state=None):
        &#34;&#34;&#34;
        Execute the LEiDA pipeline: 
            1) Compute the instantaneous phase of each signal, the
            phase-coherence matrices, and extract the eigenvectors.

            2) Fit a k-means model for each k partition, identify
            the phase-locking (PL) states (centroids), and assign
            a cluster label to each observation (eigenvectors).

            3) Compute the dwell times, occupancies, and transitions
            probabilities for each &#39;k&#39; partition.

            4) Perform a statistical analysis of occupancies and
            dwell times for each &#39;k&#39; partition.

        Params:
        -------
        TR : None | np.float | int.
            Specify the Repetition Time of the fMRI data.
            If &#39;None&#39;, then the dwell times will express the mean
            lifetime of each PL state in TR units, instead of seconds.

        paired_tests : bool. Default: False.
            Specify if groups are independent or related/paired,
            to run the correct statistical tests.

        n_perm : int.
            Select the number of permutations that will be applied
            when running the statistical analysis of dwell times
            and occupancies for each k.

        save_results : bool.
            Whether to create folders and files to save the
            results on local folder. If True, then a folder
            called &#39;LEiDA_results&#39; containing all the results
            will be created. Note: These results can be easely
            retrieved later using the &#39;DataLoader&#39; class.

        random_state : None | int.
            Determines random number generation for centroid
            initialization. Use an int to make the randomness
            deterministic.
        &#34;&#34;&#34;
        self._K_min_ = 2
        self._K_max_ = 20
        
        #validate provided &#39;TR&#39;
        if TR is not None and not isinstance(TR,(int,float)):
            raise TypeError(&#34;&#39;TR&#39; must be &#39;None&#39;, and integer or a floating number!&#34;)

        #validate paired_tests input
        if not isinstance(paired_tests,bool):
            raise TypeError(&#34;&#39;paired_tests&#39; must be either True or False.&#34;)
        
        #check that a valid number of permutations was provided
        if not isinstance(n_perm,int):
            raise TypeError(&#34;&#39;n_perm&#39; must be an integer!&#34;)
        else:
            if n_perm&lt;100:
                raise ValueError(&#34;The number of permutations cannot be lower than 100.&#34;)

        #validate &#39;save_results&#39; input
        if not isinstance(save_results,bool):
            raise TypeError(&#34;&#39;save_results&#39; must be a boolean value (True or False)!&#34;)

        #Run the analysis
        self._results_path_ = &#39;LEiDA_results&#39;

        self.eigenvectors,self._clustering_,self._dynamics_ = self._execute_all(
            TR=TR,
            random_state=random_state,
            paired_tests=paired_tests,
            n_perm=n_perm,
            save_results=save_results,
            )

        self.predictions = self._clustering_.predictions
        self._classes_lst_ = np.unique(self.eigenvectors.condition).tolist()
        self._N_classes_ = len(self._classes_lst_)
        self._is_fitted = True

    def _execute_all(self,TR=None,random_state=None,paired_tests=False,n_perm=5_000,save_results=True):
        &#34;&#34;&#34;
        Perform all the steps of the LEiDA (for each subject
        and group/condition/session):

        1) Compute neccesary data:
            a) Computes the instantaneous phase of each
            signal at each time point.
            b) Computes the phase-coherence or PL matrices
            from the previously computed signals phases.
            c) Extracts the leading eigenvector from each
            phase-coherence matrix at time t.

        2) Compute dynamics metrics for each K.
        3) Performs statistical analysis of occupancies and
        dwell times of each PL pattern and for each K partition.

        Params:
        -------
        TR : None | np.float or int. Default = None.
            Specify the Repetition Time of the fMRI data.
            If None, the Dwell times express the mean
            lifetime duration of each PL state in volumes.

        random_state : None or int.
            Determines random number generation for centroid
            initialization. Use an int to make the randomness
            deterministic.

        paired_tests : bool. Default: False.
            Specify if groups are independent or related/paired,
            to run the correct statistical tests.

        n_perm : int. Default = 5000.
            Select number of permutations to apply when running
            the statistical tests.

        save_results : bool. Default = True.
            Whether to save the results on local disk.
        
        Returns: 
        --------
        df_eigens : pd.DataFrame.
            Contains the computed eigenvectors.
            1st column contains subject ids, and
            2nd column the group/condition.

        clustering : dict/bunch.
            Contains the k-means predictions for each
            K partition, the scores of clustering performance,
            and the fitted models.

        dynamics : dict/bunch.
            Contains the computed occupancies, dwell times,
            transitions probabilities and statistical analysis
            results for each K.
        &#34;&#34;&#34;
        subject_ids = list(self.time_series.keys()) #list of subject ids
        N_subjects = len(subject_ids) #number of provided subjects

        #creating folder to save results
        if save_results:
            if os.path.exists(self._results_path_):
                raise Warning(&#34;EXECUTION ABORTED: The folder &#39;LEiDA_results&#39; already &#34;
                            &#34;exists. If you have results from earlier executions of &#34;
                            &#34;the analysis, consider changing the folder&#39;s name or moving &#34;
                            &#34;the folder to another location.&#34;)
            else:
                try:
                    print(f&#34;\n-Creating folder to save results: &#39;./{self._results_path_}&#39;&#34;)
                    os.makedirs(self._results_path_)
                except:
                    raise Exception(&#34;The folder to save the results could&#39;t be created.&#34;)

        #creating variables to save results    
        eigens = []
        sub_list, class_list = [], []

        #Starting process
        print(&#34;\n-STARTING THE PROCESS:\n&#34;
            &#34;========================\n&#34;
            f&#34;-Number of subjects: {N_subjects}&#34;)
            
        print(&#34;\n 1) EXTRACTING THE EIGENVECTORS.\n&#34;)

        for sub_idx,sub_id in enumerate(subject_ids): #for each subject
            #get current subject signals
            tseries = self.time_series[sub_id]
            N_volumes = tseries.shape[1]-2

            print(f&#34;SUBJECT ID: {sub_id} ({tseries.shape[1]} volumes)&#34;)
            
            #Extract the eigenvectors from each phase-coherence matrix at time t.
            eigens.append(
                get_eigenvectors(phase_coherence(hilbert_phase(tseries)))
                )

            #Append metadata to lists (to complete the eigenvectors dataset)
            for volume in range(N_volumes):
                sub_list.append(sub_id)
                if len(self.classes[sub_id])&gt;1:
                    class_list.append(self.classes[sub_id][volume+1])
                else:
                    class_list.append(self.classes[sub_id][0])
        
        # creating dataframe with the extracted eigenvectors
        # and metadata (subjects ids and conditions)
        df_eigens = pd.DataFrame(np.vstack(eigens),columns=self.rois_labels)
        df_eigens.insert(0,&#39;subject_id&#39;,sub_list)
        df_eigens.insert(1,&#39;condition&#39;,class_list)
        
        #saving results
        if save_results:
            try:
                df_eigens.to_csv(f&#39;{self._results_path_}/eigenvectors.csv&#39;,sep=&#39;\t&#39;,index=False)
            except:
                print(&#34;Warning: An error ocurred when saving the &#39;eigenvectors.csv&#39; file to local folder.&#34;)
        
        #clustering
        print(&#34;\n 2) RUNNING K-MEANS CLUSTERING ON EIGENVECTORS.&#34;)
        predictions,clustering_performance,models = identify_states(
            df_eigens,
            K_min=self._K_min_,
            K_max=self._K_max_,
            random_state=random_state,
            save_results=save_results,
            path=self._results_path_ if save_results else None
            )


        #computing dynamical systems theory metrics for each K
        print(&#34;\n 3) COMPUTING THE DYNAMICAL SYSTEMS THEORY METRICS FOR EACH K.&#34;)
        dynamics_data = compute_dynamics_metrics(
            predictions,
            TR=TR,
            save_results=save_results,
            path=self._results_path_ if save_results else None
            )

        #Statistical analysis of occupancies and dwell times for each k
        print(&#34;\n 4) EXECUTING THE STATISTICAL ANALYSIS OF &#34;
            &#34;OCCUPANCIES AND DWELL TIMES FOR EACH K.&#34;)
        stats = _compute_stats(
            dynamics_data,
            paired_tests=paired_tests,
            n_perm=n_perm,
            save_results=save_results,
            path=self._results_path_ if save_results else None
            )

        #Plotting statistical analyses results
        # (scatter plots and barplots&#39; pyramid)
        print(&#34;\n-Creating figures with the statistical analyses results for dwell times &#34;
            &#34;and fractional occupancies. This may take some time. Please wait...&#34;)

        classes = np.unique(df_eigens.condition)

        for metric in [&#39;occupancies&#39;,&#39;dwell_times&#39;]:
            pooled_stats = pd.concat((stats[metric]),ignore_index=True)

            for conditions in combinations(classes,2):
                pooled_stats_ = pooled_stats[
                    (pooled_stats.group_1.isin(conditions))
                    &amp;
                    (pooled_stats.group_2.isin(conditions))
                    ].reset_index(drop=True)

                #plot pyramid
                dyn_data = {k:v[v.condition.isin(conditions)] for k,v in dynamics_data[metric].items()}
                plot_pyramid(
                    dyn_data,
                    pooled_stats_,
                    K_min=self._K_min_,
                    K_max=self._K_max_,
                    metric_name=metric,
                    despine=True
                    )
                if save_results:
                    plt.savefig(f&#39;{self._results_path_}/dynamics_metrics/{conditions[0]}_vs_{conditions[-1]}_{metric}_barplot_pyramid.png&#39;,dpi=300)

                #plot p-values scatter plot
                scatter_pvalues(pooled_stats_,metric=metric,fill_areas=True)
                if save_results:
                    plt.savefig(f&#39;{self._results_path_}/dynamics_metrics/{conditions[0]}_vs_{conditions[-1]}_{metric}_scatter_pvalues.png&#39;,dpi=300)

        #Preparing output
        clustering = Bunch(
            predictions =  predictions,
            performance = clustering_performance,
            models = models
            )

        dynamics = Bunch(
                dwell_times = dynamics_data[&#39;dwell_times&#39;],
                occupancies = dynamics_data[&#39;occupancies&#39;],
                transitions = dynamics_data[&#39;transitions&#39;],
                stats = stats
            )

        print(&#34;\n** THE ANALYSIS HAS FINISHED SUCCESFULLY!&#34;)
        if save_results:
            print(f&#34;-All the results were save in &#39;./{self._results_path_}&#39;&#34;)

        print(&#34;\n-You can explore the results in detail by using &#34;
            &#34;the methods and attributes of the Leida class.&#34;)
        
        #output
        return df_eigens,clustering,dynamics

    def load_model(self,k=2):
        &#34;&#34;&#34;
        Load fitted model for a specific &#39;k&#39; partition.
        Given that each model is an instance of the KMeansLeida
        class, once loaded you can access all the object methods
        and attributes.

        Params:
        -------
        k : int.
            Select the partition of interest.
        
        Returns:
        -------
        model : KMeansLeida instance.
            The fitted model that was used to predict
            the cluster labels of each observation.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        model = self._clustering_.models[f&#39;k_{k}&#39;]
        return model

    def load_centroids(self,k=2):
        &#34;&#34;&#34;
        Return the computed clusters centroids
        for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the partition of interest.
        
        Returns:
        -------
        centroids : pd.DataFrame with shape (n_centroids,n_rois).
            Contains the computed centroids for
            the selected k partition.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        centroids = pd.DataFrame(self.load_model(k=k).cluster_centers_,columns=self.rois_labels)
        return centroids

    def centroids_distances(self,k=2):
        &#34;&#34;&#34;
        Transform eigenvectors to a cluster-distance space. 
        Returns the distance between each eigenvector and the
        cluster centroids of the selected &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the partition of interest.
        
        Returns:
        --------
        distances : pd.DataFrame.
            Contains the distace between each eigenvector and
            each cluster centroid for the select &#39;k&#39; partition.
            1st column contains &#39;subject_id&#39;, 2nd column the
            &#39;condition&#39;, and the rest of columns the distances
            to the centroids.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)

        model = self.load_model(k=k)
        distances = pd.DataFrame(model.transform(self.eigenvectors.iloc[:,2:].values))
        distances.columns = [f&#39;centroid_{centroid+1}&#39; for centroid in range(k)]
        distances = pd.concat((self.eigenvectors[[&#39;subject_id&#39;,&#39;condition&#39;]],distances),axis=1)
        return distances

    def stats(self,k=2,metric=&#39;occupancies&#39;):
        &#34;&#34;&#34;
        Retrieve the results from the statistical analysis of 
        a &#39;metric&#39; of interest (&#39;occupancies&#39; or &#39;dwell_times&#39;)
        for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the &#39;k&#39; partition of interest.

        metric : str.
            Select the metric to retrieve results.

        Returns:
        --------
        stats : pandas.dataframe.
            Results of the statistical analysis
            of each PL state.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_metric(metric)

        df_stats = self._dynamics_.stats[metric][f&#39;k_{k}&#39;]
        return df_stats

    def dwell_times(self,k=2):
        &#34;&#34;&#34;
        Return the computed dwell times of each
        phase-locking state for a specific &#39;k&#39;
        partition.

        Params:
        -------
        k : int.
            Specify the K-Means partition of interest.

        Returns:
        --------
        dwell_times : pd.DataFrame.
            Contains the computed dwell times of each
            PL state for each subject for the selected
            &#39;k&#39; partition.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        return self._dynamics_.dwell_times[f&#39;k_{k}&#39;]

    def transitions(self,k=2):
        &#34;&#34;&#34;
        Return the computed transition probabilities between
        phase-locking states for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Specify the K-Means partition of interest.

        Returns:
        --------
        transitions : pd.DataFrame.
            Contains the computed transition probabilities
            between PL states for each subject for the selected
            &#39;k&#39; partition.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        return self._dynamics_.transitions[f&#39;k_{k}&#39;]

    def occupancies(self,k=2):
        &#34;&#34;&#34;
        Return the computed fractional occupancy of each
        phase-locking state for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Specify the K-Means partition of
            interest.

        Returns:
        --------
        occupancies : pd.DataFrame.
            Contains the computed fractional occupancy
            of each PL state for each subject for the
            selected &#39;k&#39; partition.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        return self._dynamics_.occupancies[f&#39;k_{k}&#39;]

    def significant_states(self,metric=&#34;occupancies&#34;):
        &#34;&#34;&#34;
        Return a dataframe containing only the statistics
        of the phase-locking states that are significantly
        different between groups.

        Params:
        -------
        metric : str.
            Metric of interest (Options: &#39;occupancies&#39;,
            &#39;dwell_times&#39;).

        Returns:
        --------
        stats : pandas.dataframe.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_metric(metric)

        stats = self._pool_stats(metric=metric)
        has_results = True if stats[stats.reject_null==True].shape[0]&gt;=1 else False #check if some result was significant
        if has_results:
            return stats[stats.reject_null==True]
        else:
            print(&#34;No significant results were founded.&#34;)
            return None

    def state_rois(self,k=2,state=1):
        &#34;&#34;&#34;
        Get a list with the names of the ROIs/parcels that
        participates in a specific phase-locking (PL) state.

        Params:
        -------
        k : int.
            Select the partition.

        state : int.
            Select the PL pattern or state of
            interest.

        Returns:
        --------
        rois : list.
            Contains the names of the ROIs that
            are part of the selected PL state.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        data_k = self.load_centroids(k=k).iloc[state-1,:].reset_index()
        data_k.columns = [&#39;rois&#39;,&#39;value&#39;]
        rois = list(data_k[data_k.value&gt;0][&#39;rois&#39;])
        return rois

    def group_static_fc(self,group=None,plot=True,cmap=&#39;jet&#39;,darkstyle=False):
        &#34;&#34;&#34;
        Compute the mean static functional
        connectivity matrix of a particular
        group/condition.

        Params:
        --------
        group : str.
            Specify the group of interest.

        plot : bool.
            Whether to create a heatmap showing
            the connectivity matrix.

        cmap : str.
            If plot=True, then select the colormap
            to use for the heatmap. Default = &#39;jet&#39;.

        darkstyle : bool.
            Whether to use a dark background
            for plotting.

        Returns:
        --------
        static_fc : ndarray with shape (N_ROIs, N_ROIs).
            The computed static functional connectivity
            matrix.
        &#34;&#34;&#34;
        if not isinstance(group,str):
            raise TypeError(&#34;&#39;group&#39; must be a string.&#34;)

        #create list with conditions labels
        conditions = []
        for val in self.classes.values():
            for item in val:
                conditions.append(item)

        if len(conditions) != len(self.time_series.keys()):
            raise Exception(&#34;This method is only available in &#34;
                &#34;cases where each subject has only one condition label.&#34;)
        if group not in conditions:
            raise ValueError(&#34;&#39;group&#39; must be present in your data. &#34;
                f&#34;Possible options are: {[i for i in np.unique(conditions)]}.&#34;)       

        subjects_ids = [sub for sub,condition in zip(self.time_series.keys(),conditions) if condition==group]
        N_subjects = len(subjects_ids)
        N_rois = len(self.rois_labels)
        pooled_static_fc = np.empty((N_rois,N_rois,N_subjects))
        
        for idx,sub in enumerate(subjects_ids):
            pooled_static_fc[:,:,idx] = np.corrcoef(self.time_series[sub])
        
        static_fc = np.mean(pooled_static_fc,axis=-1)

        if plot:
            plt.ion()
            with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
                plt.figure()
                sns.heatmap(
                    static_fc,
                    vmin=-1,
                    vmax=1,
                    center=0,
                    square=True,
                    cmap=cmap,
                    cbar_kws={&#39;label&#39;: &#39;Pearson\ncorrelation&#39;,&#39;shrink&#39;: 0.5}
                )

                plt.xlabel(&#39;Brain region&#39;,fontsize=16,labelpad=20)
                plt.ylabel(&#39;Brain region&#39;,fontsize=16,labelpad=20)
                plt.title(group)
                plt.xticks(
                        np.arange(20,N_rois,20),
                        np.arange(20,N_rois,20).tolist(),
                        rotation=0
                        )
                plt.yticks(
                        np.arange(20,N_rois,20),
                        np.arange(20,N_rois,20).tolist()
                        )
                plt.tick_params(
                    axis=&#39;both&#39;,         
                    which=&#39;both&#39;,     
                    bottom=False,
                    left=False
                    )
                plt.tight_layout()
                #plt.show()

        return static_fc

    def group_transitions(self,k=2,metric=&#39;mean&#39;,cmap=&#39;inferno&#39;,darkstyle=False):
        &#34;&#34;&#34;
        Compute and plot the mean or median transition
        probabilities matrix of each group/condition.

        Params:
        -------
        k : int.
            The k-means partition of interest.

        metric : str.
            Whether to plot the &#39;mean&#39; or &#39;median&#39;
            matrices.

        cmap : str.
            Colormap to use in the created heatmaps.

        darkstyle : bool.
            Whether to use a dark background for
            plotting.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        mats = group_transition_matrix(
            self._dynamics_.transitions[f&#39;k_{k}&#39;],
            metric=metric,
            cmap=cmap,
            darkstyle=darkstyle
            )

        return mats

    def overlap_withyeo(self,parcellation=None,n_areas=None,k=2,state=None,darkstyle=False):
        &#34;&#34;&#34;
        Compute the overlap between the 7 resting-state
        networks defined in Yeo et al. (2011) and the brain
        cortical regions/parcels of the phase-locking state
        of interest. The correlations are shown in a barplot,
        and a dataframe with the correlations and p-values is
        returned.

        Params:
        --------
        parcellation : str.
            Specify path to your parcellation .nii file.
            Note: the parcellation must be of 2mm resolution.

        n_areas : None | int.
            Analyze only the first n areas from the provided
            parcellation. 
            Usefull when the parcellation contains subcortical
            regions that must be ignored when computing the overlap
            with Yeo&#39;s cortical networks.

        k : int.
            Select the partition.

        state : int.
            Select the PL pattern or state of
            interest.

        darkstyle : bool.
            Whether to use a dark theme for the plot.

        Returns:
        --------
        overlap : pandas.dataframe with shape (7networks,3).
            Contains the correlation coefficient (and p-value)
            between the selected phase-locking state and each
            of the 7 resting-state networks from Yeo (2011).
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        centr = {}

        for k_ in range(self._K_min_,self._K_max_+1):
            cent = self.load_centroids(k_)
            cent.insert(0,&#39;state&#39;,[i+1 for i in range(cent.shape[0])])
            cent.insert(0,&#39;k&#39;,k_)
            centr[f&#39;k{k_}&#39;] = cent
        
        centr = pd.concat(centr,ignore_index=True)

        corr,pvals = rsnets.compute_overlap(
            centr,
            parcellation=parcellation,
            n_areas=n_areas
            )

        overlap = rsnets.state_overlap(
            corr,
            pvals,
            k=k,
            state=state,
            plot=True,
            darkstyle=darkstyle
            )

        return overlap

    def _pool_stats(self,metric=&#34;occupancies&#34;):
        &#34;&#34;&#34;
        Pool the stats for each k for the selected
        metric in a single dataframe.

        Params:
        --------
        metric : str.
            Specify the metric of interest
            (&#39;occupancies&#39;,&#39;dwell_times&#39;,&#39;transitions&#39;).
        &#34;&#34;&#34;
        self._check_is_fitted()

        data = {}
        for k in np.arange(self._K_min_,self._K_max_+1):
            data[k] = self.stats(k=int(k),metric=metric)
        data = pd.concat((data),ignore_index=True)
        return data

    #Parameters validation

    def _validate_constructor_params(self):
        &#34;&#34;&#34;Validate input data provided in &#39;path&#39;.&#34;&#34;&#34;
        
        #1.validate time series.
        #check whether all the subjects have
        #the same number of brain regions
        nrois = [self.time_series[sub].shape[0] for sub in self.time_series.keys()]
        if np.unique(nrois).size&gt;1:
            raise Exception(&#34;The number of brain regions must be &#34;
                            &#34;the same for all the subjects.&#34;)

        #check that the number of ROIs labels
        #coincide with the number of ROIs in time series
        if np.unique(nrois).item()!=len(self.rois_labels):
            raise Exception(f&#34;The number of brain regions in time series ({np.unique(nrois).item()}) must &#34;
                            f&#34;coincide with the number of ROIs labels ({len(self.rois_labels)}).&#34;)

        #2.validate metadata (labels info).
        #check if the number of subjects in &#39;time_series&#39; 
        #and &#39;classes&#39; dictionaries coincide.
        nsub_signals = len(self.time_series.keys())
        nsub_classes = len(self.classes.keys())
        if nsub_signals != nsub_classes:
            raise Exception(f&#34;The number of subjects in &#39;time_series&#39; (n={nsub_signals}) &#34;
                            f&#34;and&#39;metadata&#39; (n={nsub_classes}) must be equal.&#34;)
        #check if each subject in &#39;time_series&#39; has his corresponding metadata.
        elif bool(set(self.time_series.keys())-set(self.classes.keys())):
            raise Exception(f&#34;The metadata of the following subject/s was not founded:\n &#34;
                            f&#34;{set(self.time_series.keys())-set(self.classes.keys())}&#34;)
        #check if the number of labels match with the number of volumes.
        else:
            n_labels = [len(self.classes[sub]) for sub in self.classes.keys()] #get n of labels per subject
            if np.max(n_labels)!=1:
                labels_info = list()
                for sub in self.time_series.keys():
                    labels_info.append(
                        {&#39;subject_id&#39;:sub,
                        &#39;n_volumes&#39;:self.time_series[sub].shape[1],
                        &#39;n_labels&#39;:len(self.classes[sub])}
                    )
                labels_info = pd.DataFrame(labels_info)
                
                mismatchs_ids = labels_info[~(labels_info[&#39;n_volumes&#39;] == labels_info[&#39;n_labels&#39;])].subject_id.tolist()

                if bool(mismatchs_ids):
                    print(labels_info[labels_info.subject_id.isin(mismatchs_ids)])
                    raise Exception(&#34;Some subject/s have a different number of &#34;
                                    &#34;volumes and labels!&#34;)
        
            #check if more than 1 condition is present in &#39;metadata&#39;
            conditions = []
            for val in self.classes.values():
                for item in val:
                    conditions.append(item)
            if np.unique(conditions).size==1:
                raise Exception(&#34;The number of conditions must be at least 2!&#34;)

        #3.validate rois coordinates
        if self.rois_coordinates is None:
            print(&#34;The ROIs coordinates couldn&#39;t be loaded from the provided &#39;data_path&#39;. &#34;
                &#34;Brain plots that show nodes in brain space will not be executed in consequence.&#34;)
        else:
            #check if the number of roi labels match 
            #with the number of MNI coordinates.
            if len(self.rois_labels) != self.rois_coordinates.shape[0]:
                raise Exception(f&#34;The number of &#39;ROIs labels&#39; ({len(self.rois_labels)} were provided) &#34;
                    f&#34;must coincide with the number of provided coordinates ({self.rois_coordinates.shape[0]} were provided)&#34;)

        print(&#34;All the data has been sucesfully loaded.&#34;)

    def _check_is_fitted(self):
        &#34;&#34;&#34;
        Check if the k-means models had been already fitted.
        &#34;&#34;&#34;
        if not hasattr(self,&#34;_is_fitted&#34;):
            raise Exception(&#34;You have to fit the models first by using the &#39;fit_predict&#39; method.&#34;)

    #Plotting methods

    def plot_clusters3D(self,k=2,clusters_colors=None,grid=True,alpha=.7,dot_size=3,edgecolor=None,darkstyle=False):
        &#34;&#34;&#34;
        Visualize the identified clusters (BOLD phase-locking
        states) in a 3D scatter plot, which constitutes a
        low-dimensional representation of the &#39;state space&#39;. 
        Method : take the eigenvectors and extract the first
        three principal components to reduce the dimensionality
        of the data to a 3D space. Each dot in the plot thus
        represents a single eigenvector, and is coloured according
        to the cluster it belongs to.
        
        Params:
        -------
        k : int.
            Specify the partition to plot.

        clusters_colors : list (optional). 
            Provide a list with the desired color
            of each cluster. If not provided, then
            a predefined set of colors will be used.

        grid : bool. 
            Whether to show grid or not.

        alpha : float. 
            Set transparency of dots.

        dot_size : float. 
            Select the dot size.

        edge_color : None | str.
            Specify an edge color to use
            on dots.

        darkstyle : bool.
            Whether to use a dark theme for
            the plot.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        X = np.array(self.eigenvectors.iloc[:,2:], dtype=np.float32) #keep array containing only the eigenvectors
        y = self._clustering_.predictions[f&#39;k_{k}&#39;].values #keep 1D array with the labels of each eigenvector

        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            plot_clusters3D(
                X,
                y,
                clusters_colors=clusters_colors,
                grid=grid,
                alpha=alpha,
                dot_size=dot_size,
                edgecolor=edgecolor
                )

    def plot_voronoi_cells(self,k=2):
        &#34;&#34;&#34;
        Plot the clusters centroids in a 2D Voronoi
        cells space. Performs a PCA to reduce the
        dimensionality of the original centroid space
        to a 2D space.

        Params:
        --------
        k : int.
            Select the clustering solution to plot.

        Note: see Vohryzek, Deco et al. (2020) p.4
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        centroids = self.load_centroids(k=k).values 
        plot_voronoi(centroids)

    def plot_pvalues(self,metric=&#39;occupancies&#39;,conditions=None,darkstyle=False,fill_areas=True):
        &#34;&#34;&#34;
        Create a scatter plot showing the p-values
        obtained by the statistical analysis of a given
        &#39;metric&#39; across the explored &#39;k&#39; range.

        Params:
        -------
        metric : str. 
            Specify the metric of interest
            (&#39;occupancies&#39;,&#39;dwell_times&#39;,&#39;transitions&#39;).

        conditions : None | list. Optional
            (Usefull only when your data contains more
            than two conditions). You can provide a list
            specifying only two conditions of interest to
            plot. Otherwise create a plot for each pair of
            conditions. 

        darkstyle : bool.
            Whether to use a dark theme for
            the plots.

        fill_areas : bool.
            Select whether to fill the significance
            areas with color.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_metric(metric)

        if not isinstance(fill_areas,bool) or not isinstance(darkstyle,bool):
            raise TypeError(&#34;&#39;fill_areas&#39; and &#39;darkstyle&#39; must be True or False!&#34;)

        if conditions is not None:
            if not isinstance(conditions,list) or len(conditions)!=2:
                raise Exception(&#34;If provided, &#39;conditions&#39; must be a list with two items.&#34;)
            for cond in conditions:
                if cond not in self._classes_lst_:
                    raise Exception(f&#34;&#39;{cond}&#39; was not founded in the data. &#34;
                                    f&#34; Valid options are: {self._classes_lst_}&#34;)
        else:
            conditions = self._classes_lst_.copy()

        pooled_stats = self._pool_stats(metric=metric)

        for cond in combinations(conditions,2):
            pooled_stats_ = pooled_stats[
                    (pooled_stats.group_1.isin(cond))
                    &amp;
                    (pooled_stats.group_2.isin(cond))
                    ].reset_index(drop=True)

            scatter_pvalues(pooled_stats_,metric=metric,darkstyle=darkstyle,fill_areas=fill_areas)

    def plot_states_nodes(self,k=2,state=1,node_size=15,show_labels=True,open=True,save=False):
        &#34;&#34;&#34;
        Create a 3D interactive figure embedded in a
        .html file showing the BOLD phase-locking (PL)
        states in anatomical MNI space. Each parcel/ROI
        is represented as a node. Nodes that are part of
        the PL pattern are coloured in red, and the rest
        of nodes are coloured in blue.

        Params:
        -------
        k : int.
            Select the partition of interest.

        state : int or str.
            Use an integer to plot a single
            PL state of interest, or &#39;all&#39;
            to plot all the PL states of the
            selected K partition.

        node_size: int or float.
            Define the size of the nodes. Nodes
            that don&#39;t belong to the pattern are
            plotted smaller.

        show_labels : bool.
            Whether to show each ROI label.

        open : bool. 
            Whether to open the plots in web
            browser. If False, you can open the
            figures using the &#39;.open_in_browser()&#39;
            method of the returned object/s.

        save : bool.
            Whether to save each plot in a
            .html file. If True, the files
            are saved in &#39;LEiDA_results/brain_plots&#39;.

        Returns:
        --------
        plot/s : dict or single figure.
            If state=&#39;all&#39;, return a dictionary
            that contains the constructed plots.
            They can be opened or saved using
            &#39;.open()&#39; and &#39;.save_as_html(path)&#39;,
            respectively. If state=int, then return
            a single figure.
        &#34;&#34;&#34;
        self._check_is_fitted()
        if self.rois_coordinates is None:
            raise Exception(&#34;You can&#39;t create this plot because the &#34;
                            &#34;ROI&#39;s coordinates could&#39;t be loaded.&#34;)

        _check_k_input(self._K_min_,self._K_max_,k)
        centroids = self.load_centroids(k=k).values
        plots = brain_states_nodes(
            centroids,
            self.rois_coordinates,
            node_size=node_size,
            state=state,
            nodes_labels=None if not show_labels else self.rois_labels,
            open=open
            )

        if save:
            _save_html(self._results_path_,plots,k,state,plot_type=&#39;nodes&#39;)

        return plots

    def plot_states_network(self,k=2,state=1,node_size=8,node_color=&#39;infer&#39;,linewidth=3,open=True,save=False):
        &#34;&#34;&#34;
        Create a 3D interactive figure embedded in a
        .html file showing the BOLD phase-locking (PL)
        states as a connected network. All the ROIs/parcels
        that belong to the selected phase-locking state are
        connected between each other.

        Params:
        -------
        k : int.
            Select the partition of interest.

        state : int or str.
            Use an integer to plot a single
            PL state of interest, or &#39;all&#39;
            to plot all the PL states of the
            selected K partition.

        node_size : int. 
            Select the size of the nodes.

        node_color : str. 
            Select the color of the nodes. If
            &#39;infer&#39;, then the nodes participating
            in the PL states are colored red and
            the rest blue. If &#39;black&#39;, then all the
            nodes are colored in the same way.

        linewidth : int. 
            Select the size of the edges
            connecting the nodes.

        open : bool. 
            Whether to open the plots in web
            browser. If False, you can open the
            figures using the &#39;.open_in_browser()&#39;
            method of the returned object/s.

        save : bool.
            Whether to save each plot in a
            .html file. If True, the files
            are saved in &#39;LEiDA_results/brain_plots&#39;.

        Returns:
        --------
        plot/s : dict or single figure.
            If state=&#39;all&#39;, return a dictionary
            that contains the constructed plots.
            They can be opened or saved using
            &#39;.open()&#39; and &#39;.save_as_html(path)&#39;,
            respectively. If state=int, then return
            a single figure.
        &#34;&#34;&#34;
        if self.rois_coordinates is None:
            raise Exception(&#34;You can&#39;t create this plot because the &#34;
                            &#34;ROI&#39;s coordinates could&#39;t be loaded.&#34;)
        
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        if not isinstance(state,(int,str)):
            raise TypeError(&#34;&#39;state&#39; must be either &#39;all&#39; or an integer &#34;
                            &#34;specifying the number of a particular PL state.&#34;)
        if isinstance(state,str):
            if state!=&#39;all&#39;:
                raise ValueError(&#34;If a string is provided, &#39;state&#39; must be &#39;all&#39;!&#34;)
        else:
            _check_state(k,state)

        centroids = self.load_centroids(k=k).values #load centroids for the selected k

        #plotting
        plot = brain_states_network(
            centroids,
            self.rois_coordinates,
            state=state,
            node_size=node_size,
            node_color=node_color,
            linewidth=linewidth,
            open=open,
            )

        #saving figures
        if save:
            _save_html(self._results_path_,plot,k,state,plot_type=&#39;network&#39;)
            
        return plot

    def plot_states_in_bold(self,subject_id,k=2,alpha=.5,darkstyle=False):
        &#34;&#34;&#34;
        Create plot showing the time-series of BOLD signals, 
        highlighting the dominant phase-locking (PL) state
        of each time point or volume.

        Params:
        -------
        subject_id : str.
            Specify the &#39;id&#39; of the subject
            of interest.

        k : int.
            Select the k partition.

        alpha : float.
            Transparency of the colors that
            show the dominant PL pattern of
            each time point.

        darkstyle : bool.
            Whether to create the plot using
            a darkstyle.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        tseries = self.time_series[subject_id][:,1:-1] #get subject signals (excluding the 1st and last volumes)
        predictions = self._clustering_.predictions
        y = predictions[predictions.subject_id==subject_id][f&#39;k_{k}&#39;].values #get predictions for selected k.

        with plt.style.context(&#34;dark_background&#34; if darkstyle else &#34;default&#34;):
            states_in_bold(tseries,y,alpha=alpha)

    def plot_states_pyramid(self,metric=&#39;occupancies&#39;,conditions=None,despine=True):
        &#34;&#34;&#34;
        Create a pyramid of barplots showing the &#39;metric&#39;
        of interest for each group, cluster (PL state), and
        K partition. Each barplot (which represents a particular
        PL state) is coloured according to its associated p-value:
        -black: the p-value is higher than 0.05.
        -red: the p-value is lower than 0.05 but higher than 0.05 / k.
        -green: the p-value is lower than 0.05/k but higher than 0.05 / (k).
        -blue: the p-value is lower than 0.05 / (k).

        Params:
        -------
        metric : str.
            Select the dynamical systems theory metric
            of interest (either &#39;occupancies&#39; or &#39;dwell_times&#39;).

        conditions : None | list. Optional.
            (Usefull only when your data contains more
            than two conditions). You can provide a list
            specifying only two conditions of interest to
            plot. Otherwise create a plot for each pair of
            conditions. 

        despine : bool. Default = True.
            Whether to despine top and right axes of the
            subplots.
        &#34;&#34;&#34;
        self._check_is_fitted
        _check_metric(metric)

        if conditions is not None:
            if not isinstance(conditions,list) or len(conditions)!=2:
                raise Exception(&#34;If provided, &#39;conditions&#39; must be a list with two items.&#34;)
            for cond in conditions:
                if cond not in self._classes_lst_:
                    raise Exception(f&#34;&#39;{cond}&#39; was not founded in the data. &#34;
                                    f&#34; Valid options are: {self._classes_lst_}&#34;)
        else:
            conditions = self._classes_lst_.copy()

        pooled_stats = self._pool_stats(metric=metric)

        for cond in combinations(conditions,2):
            pooled_stats_ = pooled_stats[
                    (pooled_stats.group_1.isin(cond))
                    &amp;
                    (pooled_stats.group_2.isin(cond))
                    ].reset_index(drop=True)

            dyn_metric = self._dynamics_[metric]
            dyn_metric = {k:v[v.condition.isin(conditions)] for k,v in dyn_metric.items()}

            plot_pyramid(
                dyn_metric,
                pooled_stats_,
                K_min=self._K_min_,
                K_max=self._K_max_,
                despine=despine
                )

    def barplot_centroids(self,k=2,state=&#39;all&#39;):
        &#34;&#34;&#34;
        Create either subplots with barplots showing the
        values of each cluster centroid for the selected &#39;k&#39;
        partition, or a single barplot showing the values
        of a specific phase-locking state.

        Params:
        ------
        k : int.
            Select the partition of interest.

        state : str or int.
            Specify if plot all the states for
            the selected &#39;k&#39;, or a single state
            of interest.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        centroids = np.array(self.load_centroids(k=k),dtype=np.float32) #get centroids of the selected &#39;k&#39;.
        if state==&#39;all&#39;:
            barplot_states(centroids,self.rois_labels)
        else:
            _check_state(k,state)
            barplot_eig(centroids[state-1,:],self.rois_labels)
            plt.title(f&#39;PL pattern {state}&#39;,fontsize=18,pad=15)
            plt.tight_layout()

    def plot_clustering_performance(self):
        &#34;&#34;&#34;
        Create a 2x2 panel with lineplots showing
        the clustering evaluation metrics for each
        k partition explored (Dunn score, distortion,
        silhouette score, and Davis-Bouldin score).
        &#34;&#34;&#34;
        self._check_is_fitted()
        plot_clustering_scores(self._clustering_.performance)

    def plot_states_network_glass(self,k=2,darkstyle=False):
        &#34;&#34;&#34;
        Create a glass brain (axial view) showing the
        network representation of each phase-locking
        (PL) state for the selected &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the partition of interest.

        darkstyle : bool.
            Whether to use a dark theme for
            the plots.
        &#34;&#34;&#34;
        if self.rois_coordinates is None:
            raise Exception(&#34;You can&#39;t create this plot because the ROI&#39;s coordinates could&#39;t be loaded.&#34;)

        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        pl_states = self.load_centroids(k=k).values

        with plt.style.context(&#34;dark_background&#34; if darkstyle else &#34;default&#34;):
            states_k_glass(pl_states,self.rois_coordinates,darkstyle=darkstyle)

    def plot_states_on_surf(self,k=2,state=&#39;all&#39;,parcellation=None,discretize=True,cmap=&#39;auto&#39;,darkstyle=False,open=False,save=False):
        &#34;&#34;&#34;
        Create a 3D interactive figure embedded in a
        .html file showing the BOLD phase-locking (PL)
        states on cortical surface. By default, all the
        cortical regions that belong to a given PL state
        or pattern are coloured in red(s), while the rest
        of cortical regions are coloured in blue(s). You
        can change the colormap throught the &#39;cmap&#39; argument.

        Params:
        -------
        k : int.
            Partition of interest.

        state : str or int.
            Whether to plot &#39;all&#39; the PL states of
            the selected partition or a single state
            of interest.

        parcellation : str.
            Path to the .nii file containing the
            parcellation from which the time series
            were extracted.

        discretize : bool. Default = True.
            Whether to plot the raw values of the
            phase-locking state/centroid, or plot
            all the brain regions that belong to
            the phase-locking state with the same
            intensity.

        cmap : str or matplotlib colormap, optional. Default = &#39;auto&#39;.
            Colormap to use in the brain plot.
            If &#39;auto&#39;, then the brain regions that
            belong to the phase-locking state will
            be coloured in red(s), and the rest of
            regions in blue(s).

        darkstyle : bool.
            Whether to use a black background.

        open : bool. 
            Whether to open the plots in web
            browser. If False, you can open the
            figures using the &#39;.open_in_browser()&#39;
            method of the returned object/s.

        save : bool.
            Whether to save each plot in a
            .html file. If True, the files
            are saved in &#39;LEiDA_results/brain_plots&#39;.

        Returns:
        --------
        g : SurfaceView or dictionarity of SurfaceViews. 
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        if not isinstance(state,(int,str)):
            raise TypeError(&#34;&#39;state&#39; must be either &#39;all&#39; or an integer &#34;
                            &#34;specifying the number of a particular PL state&#34;)
        if isinstance(state,str):
            if state!=&#39;all&#39;:
                raise ValueError(&#34;If a string is provided, &#39;state&#39; must be &#39;all&#39;!&#34;)
        else:
            _check_state(k,state)

        centroids = self.load_centroids(k=k).values 
        if state!=&#39;all&#39;:
            centroids = centroids[state-1,:]
        
        g = brain_states_on_surf(
            centroids,
            parcellation=parcellation,
            black_bg=darkstyle,
            open=open,
            discretize=discretize,
            cmap=cmap
            )

        if save:
            _save_html(self._results_path_,g,k,state,plot_type=&#39;surface&#39;)

        return g

    def plot_states_on_surf2(self,k=2,state=1,parcellation=None,surface=&#39;pial&#39;,hemi=&#39;right&#39;,view=&#39;lateral&#39;,darkstyle=False,save=False):
        &#34;&#34;&#34;
        Plot a BOLD phase-locking state of interest 
        on cortical surface mesh. 

        Params:
        -------
        k : int.
            Partition of interest.

        state : int.
            Select the PL state/pattern of
            interest.

        parcellation : str.
            Path to the .nii file containing
            the parcellation from which the
            signals were extracted.

        surface : str.
            Specify the surface type to plot
            the pattern on. Valid options are
            &#39;pial&#39;,&#39;infl&#39;, and &#39;white&#39;.

        hemi : str.
            Select the hemisphere to plot.
            Valid options are &#39;right&#39;, &#39;left&#39;,
            or &#39;both&#39;.

        view : str
            View of the surface that is rendered. 
            Default=&#39;lateral&#39;. Options = {&#39;lateral&#39;,
            &#39;medial&#39;, &#39;dorsal&#39;, &#39;ventral&#39;, &#39;anterior&#39;,
            &#39;posterior&#39;}. If &#39;hemi&#39;=&#39;both&#39;, then &#39;dorsal&#39;
            and &#39;lateral&#39; views are displayed.

        darkstyle : bool
            Whether to use a black background.

        save : bool.
            Whether to save the created figure in
            local folder. If True, the files are
            saved in &#39;LEiDA_results/brain_plots&#39;,
            and the plot will not be displayed.

        Returns:
        --------
        g : matplotlib figure. 
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        centroids = self.load_centroids(k=k).values 
        centroid = centroids[state-1,:]

        if save: 
            path = f&#39;{self._results_path_}/brain_plots&#39;
            if not os.path.exists(path): 
                os.makedirs(path)
        #plotting
        print(&#34;\n-Creating plot. This may take &#34;
            &#34;some minutes. Please wait...&#34;)

        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            g = brain_states_on_surf2(
                centroid,
                parcellation=parcellation,
                hemi=hemi,
                surface=surface,
                view=view
                )
        
        if save:
            try:
                filename = f&#34;{path}/K{k}_PL_state_{state}_{surface}surf_{hemi}hemi_{view if hemi!=&#39;both&#39; else &#39;multiview&#39;}{&#39;_dark&#39; if darkstyle else &#39;&#39;}.png&#34;
                g.savefig(filename,dpi=300)
                plt.close()
                del g
                print(f&#34;The plot was save at: {filename}&#34;)
            except:
                raise Exception(&#34;An error occured when saving the plot.&#34;)
        else:
            return g

    def explore_state(self,k=2,state=1,darkstyle=False):
        &#34;&#34;&#34;
        Create a figure showing a phase-locking state of
        interest in different formats:
        a barplot, a network representation in brain space,
        a matrix representation, and two boxplots with the
        occupancies and dwell times for each group/condition.

        Params:
        ------
        k : int.
            Select the partition of interest.

        state : int.
            Select the PL state of interest.

        darkstyle : bool.
            Whether to use a dark background.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        centroid = self.load_centroids(k=k).values
        centroid = centroid[state-1,:]

        occ = self.occupancies(k=k)[[&#39;condition&#39;,f&#39;PL_state_{state}&#39;]]
        dt = self.dwell_times(k=k)[[&#39;condition&#39;,f&#39;PL_state_{state}&#39;]]

        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            _explore_state(
                centroid,
                self.rois_labels,
                occ,
                dt,
                self.rois_coordinates,
                state_number=state,
                darkstyle=darkstyle
                )

    def plot_states_matrices(self,k=2,cmap=&#39;jet&#39;,darkstyle=False):
        &#34;&#34;&#34;
        Take the controids resulting from the k-means
        clustering (i.e., the phase-locking states) and
        reconstruct the connectivity patterns in matrix
        format.

        Params:
        -------
        k : int.
            Specify the K partition of interest.
        
        cmap : str. Default = &#39;jet&#39;.
            Select the colormap to use.

        darkstyle : bool.
            Whether to use a black background.
        &#34;&#34;&#34;
        self._check_is_fitted()
        _check_k_input(self._K_min_,self._K_max_,k)

        if not isinstance(cmap,str):
            raise TypeError(&#34;&#39;cmap&#39; must be a string!&#34;)
        if not isinstance(darkstyle,bool):
            raise TypeError(&#34;&#39;darkstyle&#39; must be True or False!&#34;)

        _ = centroid2matrix(
            self.load_centroids(k).values,
            plot=True,
            cmap=cmap,
            darkstyle=darkstyle
            )</code></pre>
</details>
<h3>Methods</h3>
<dl>

    <dt id="pyleida._leida.Leida.fit_predict"><code class="name flex">
        <span>def <span class="ident">fit_predict</span></span>(<span>self, TR=None, paired_tests=False, n_perm=5000, save_results=True, random_state=None)</span>
        </code></dt>
        <dd>
        <div class="desc"><p>Execute the LEiDA pipeline:</p>
        <p>1) Compute the instantaneous phase of each signal, the
        phase-coherence matrices, and extract the eigenvectors.</p>
        <p>2) Fit a K-means model for each k partition, identify
        the phase-locking (PL) states (centroids), and assign
        a cluster label to each observation (eigenvectors).</p>
        
        <p>3) Compute the dwell times, occupancies, and transitions
        probabilities for each 'k' partition.</p>
        
        <p>4) Perform a statistical analysis of occupancies and
        dwell times for each 'k' partition.</p>
        
        <h2 id="params">Params:</h2>
        <p>TR : None | np.float | int.
        Specify the Repetition Time of the fMRI data.
        If 'None', then the dwell times will express the mean
        lifetime of each PL state in TR units, instead of seconds.</p>
        <p>paired_tests : bool. Default: False.
        Specify if groups are independent or related/paired,
        to run the correct statistical tests.</p>
        <p>n_perm : int.
        Select the number of permutations that will be applied
        when running the statistical analysis of dwell times
        and occupancies for each k.</p>
        <p>save_results : bool.
        Whether to create folders and files to save the
        results on local folder. If True, then a folder
        called 'LEiDA_results' containing all the results
        will be created. Note: These results can be easely
        retrieved later using the 'DataLoader' class.</p>
        <p>random_state : None | int.
        Determines random number generation for centroid
        initialization. Use an int to make the randomness
        deterministic.</p></div>
        <details class="source">
        <summary>
        <span>Expand source code</span>
        </summary>
        <pre><code class="python">def fit_predict(self,TR=None,paired_tests=False,n_perm=5_000,save_results=True,random_state=None):
            &#34;&#34;&#34;
            Execute the LEiDA pipeline: 
                1) Compute the instantaneous phase of each signal, the
                phase-coherence matrices, and extract the eigenvectors.
        
                2) Fit a k-means model for each k partition, identify
                the phase-locking (PL) states (centroids), and assign
                a cluster label to each observation (eigenvectors).
        
                3) Compute the dwell times, occupancies, and transitions
                probabilities for each &#39;k&#39; partition.
        
                4) Perform a statistical analysis of occupancies and
                dwell times for each &#39;k&#39; partition.
        
            Params:
            -------
            TR : None | np.float | int.
                Specify the Repetition Time of the fMRI data.
                If &#39;None&#39;, then the dwell times will express the mean
                lifetime of each PL state in TR units, instead of seconds.
        
            paired_tests : bool. Default: False.
                Specify if groups are independent or related/paired,
                to run the correct statistical tests.
        
            n_perm : int.
                Select the number of permutations that will be applied
                when running the statistical analysis of dwell times
                and occupancies for each k.
        
            save_results : bool.
                Whether to create folders and files to save the
                results on local folder. If True, then a folder
                called &#39;LEiDA_results&#39; containing all the results
                will be created. Note: These results can be easely
                retrieved later using the &#39;DataLoader&#39; class.
        
            random_state : None | int.
                Determines random number generation for centroid
                initialization. Use an int to make the randomness
                deterministic.
            &#34;&#34;&#34;
            self._K_min_ = 2
            self._K_max_ = 20
            
            #validate provided &#39;TR&#39;
            if TR is not None and not isinstance(TR,(int,float)):
                raise TypeError(&#34;&#39;TR&#39; must be &#39;None&#39;, and integer or a floating number!&#34;)
        
            #validate paired_tests input
            if not isinstance(paired_tests,bool):
                raise TypeError(&#34;&#39;paired_tests&#39; must be either True or False.&#34;)
            
            #check that a valid number of permutations was provided
            if not isinstance(n_perm,int):
                raise TypeError(&#34;&#39;n_perm&#39; must be an integer!&#34;)
            else:
                if n_perm&lt;100:
                    raise ValueError(&#34;The number of permutations cannot be lower than 100.&#34;)
        
            #validate &#39;save_results&#39; input
            if not isinstance(save_results,bool):
                raise TypeError(&#34;&#39;save_results&#39; must be a boolean value (True or False)!&#34;)
        
            #Run the analysis
            self._results_path_ = &#39;LEiDA_results&#39;
        
            self.eigenvectors,self._clustering_,self._dynamics_ = self._execute_all(
                TR=TR,
                random_state=random_state,
                paired_tests=paired_tests,
                n_perm=n_perm,
                save_results=save_results,
                )
        
            self.predictions = self._clustering_.predictions
            self._classes_lst_ = np.unique(self.eigenvectors.condition).tolist()
            self._N_classes_ = len(self._classes_lst_)
            self._is_fitted = True</code></pre>
        </details>
        </dd>

<dt id="pyleida._leida.Leida.barplot_centroids"><code class="name flex">
<span>def <span class="ident">barplot_centroids</span></span>(<span>self, k=2, state='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Create either subplots with barplots showing the
values of each cluster centroid for the selected 'k'
partition, or a single barplot showing the values
of a specific phase-locking state.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<p>state : str or int.
Specify if plot all the states for
the selected 'k', or a single state
of interest.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def barplot_centroids(self,k=2,state=&#39;all&#39;):
    &#34;&#34;&#34;
    Create either subplots with barplots showing the
    values of each cluster centroid for the selected &#39;k&#39;
    partition, or a single barplot showing the values
    of a specific phase-locking state.

    Params:
    ------
    k : int.
        Select the partition of interest.

    state : str or int.
        Specify if plot all the states for
        the selected &#39;k&#39;, or a single state
        of interest.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)

    centroids = np.array(self.load_centroids(k=k),dtype=np.float32) #get centroids of the selected &#39;k&#39;.
    if state==&#39;all&#39;:
        barplot_states(centroids,self.rois_labels)
    else:
        _check_state(k,state)
        barplot_eig(centroids[state-1,:],self.rois_labels)
        plt.title(f&#39;PL pattern {state}&#39;,fontsize=18,pad=15)
        plt.tight_layout()</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.centroids_distances"><code class="name flex">
<span>def <span class="ident">centroids_distances</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform eigenvectors to a cluster-distance space.
Returns the distance between each eigenvector and the
cluster centroids of the selected 'k' partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<h2 id="returns">Returns:</h2>
<p>distances : pd.DataFrame.
Contains the distace between each eigenvector and
each cluster centroid for the select 'k' partition.
1st column contains 'subject_id', 2nd column the
'condition', and the rest of columns the distances
to the centroids.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centroids_distances(self,k=2):
    &#34;&#34;&#34;
    Transform eigenvectors to a cluster-distance space. 
    Returns the distance between each eigenvector and the
    cluster centroids of the selected &#39;k&#39; partition.

    Params:
    -------
    k : int.
        Select the partition of interest.
    
    Returns:
    --------
    distances : pd.DataFrame.
        Contains the distace between each eigenvector and
        each cluster centroid for the select &#39;k&#39; partition.
        1st column contains &#39;subject_id&#39;, 2nd column the
        &#39;condition&#39;, and the rest of columns the distances
        to the centroids.
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)

    model = self.load_model(k=k)
    distances = pd.DataFrame(model.transform(self.eigenvectors.iloc[:,2:].values))
    distances.columns = [f&#39;centroid_{centroid+1}&#39; for centroid in range(k)]
    distances = pd.concat((self.eigenvectors[[&#39;subject_id&#39;,&#39;condition&#39;]],distances),axis=1)
    return distances</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.dwell_times"><code class="name flex">
<span>def <span class="ident">dwell_times</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the computed dwell times of each
phase-locking state for a specific 'k'
partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Specify the K-Means partition of interest.</p>
<h2 id="returns">Returns:</h2>
<p>dwell_times : pd.DataFrame.
Contains the computed dwell times of each
PL state for each subject for the selected
'k' partition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dwell_times(self,k=2):
    &#34;&#34;&#34;
    Return the computed dwell times of each
    phase-locking state for a specific &#39;k&#39;
    partition.

    Params:
    -------
    k : int.
        Specify the K-Means partition of interest.

    Returns:
    --------
    dwell_times : pd.DataFrame.
        Contains the computed dwell times of each
        PL state for each subject for the selected
        &#39;k&#39; partition.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)

    return self._dynamics_.dwell_times[f&#39;k_{k}&#39;]</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.explore_state"><code class="name flex">
<span>def <span class="ident">explore_state</span></span>(<span>self, k=2, state=1, darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a figure showing a phase-locking state of
interest in different formats:
a barplot, a network representation in brain space,
a matrix representation, and two boxplots with the
occupancies and dwell times for each group/condition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<p>state : int.
Select the PL state of interest.</p>
<p>darkstyle : bool.
Whether to use a dark background.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def explore_state(self,k=2,state=1,darkstyle=False):
    &#34;&#34;&#34;
    Create a figure showing a phase-locking state of
    interest in different formats:
    a barplot, a network representation in brain space,
    a matrix representation, and two boxplots with the
    occupancies and dwell times for each group/condition.

    Params:
    ------
    k : int.
        Select the partition of interest.

    state : int.
        Select the PL state of interest.

    darkstyle : bool.
        Whether to use a dark background.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)
    _check_state(k,state)

    centroid = self.load_centroids(k=k).values
    centroid = centroid[state-1,:]

    occ = self.occupancies(k=k)[[&#39;condition&#39;,f&#39;PL_state_{state}&#39;]]
    dt = self.dwell_times(k=k)[[&#39;condition&#39;,f&#39;PL_state_{state}&#39;]]

    with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
        _explore_state(
            centroid,
            self.rois_labels,
            occ,
            dt,
            self.rois_coordinates,
            state_number=state,
            darkstyle=darkstyle
            )</code></pre>
</details>
</dd>

<dt id="pyleida._leida.Leida.group_static_fc"><code class="name flex">
<span>def <span class="ident">group_static_fc</span></span>(<span>self, group=None, plot=True, cmap='jet', darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the mean static functional
connectivity matrix of a particular
group/condition.</p>
<h2 id="params">Params:</h2>
<p>group : str.
Specify the group of interest.</p>
<p>plot : bool.
Whether to create a heatmap showing
the connectivity matrix.</p>
<p>cmap : str.
If plot=True, then select the colormap
to use for the heatmap. Default = 'jet'.</p>
<p>darkstyle : bool.
Whether to use a dark background
for plotting.</p>
<h2 id="returns">Returns:</h2>
<p>static_fc : ndarray with shape (N_ROIs, N_ROIs).
The computed static functional connectivity
matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_static_fc(self,group=None,plot=True,cmap=&#39;jet&#39;,darkstyle=False):
    &#34;&#34;&#34;
    Compute the mean static functional
    connectivity matrix of a particular
    group/condition.

    Params:
    --------
    group : str.
        Specify the group of interest.

    plot : bool.
        Whether to create a heatmap showing
        the connectivity matrix.

    cmap : str.
        If plot=True, then select the colormap
        to use for the heatmap. Default = &#39;jet&#39;.

    darkstyle : bool.
        Whether to use a dark background
        for plotting.

    Returns:
    --------
    static_fc : ndarray with shape (N_ROIs, N_ROIs).
        The computed static functional connectivity
        matrix.
    &#34;&#34;&#34;
    if not isinstance(group,str):
        raise TypeError(&#34;&#39;group&#39; must be a string.&#34;)

    #create list with conditions labels
    conditions = []
    for val in self.classes.values():
        for item in val:
            conditions.append(item)

    if len(conditions) != len(self.time_series.keys()):
        raise Exception(&#34;This method is only available in &#34;
            &#34;cases where each subject has only one condition label.&#34;)
    if group not in conditions:
        raise ValueError(&#34;&#39;group&#39; must be present in your data. &#34;
            f&#34;Possible options are: {[i for i in np.unique(conditions)]}.&#34;)       

    subjects_ids = [sub for sub,condition in zip(self.time_series.keys(),conditions) if condition==group]
    N_subjects = len(subjects_ids)
    N_rois = len(self.rois_labels)
    pooled_static_fc = np.empty((N_rois,N_rois,N_subjects))
    
    for idx,sub in enumerate(subjects_ids):
        pooled_static_fc[:,:,idx] = np.corrcoef(self.time_series[sub])
    
    static_fc = np.mean(pooled_static_fc,axis=-1)

    if plot:
        plt.ion()
        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            plt.figure()
            sns.heatmap(
                static_fc,
                vmin=-1,
                vmax=1,
                center=0,
                square=True,
                cmap=cmap,
                cbar_kws={&#39;label&#39;: &#39;Pearson\ncorrelation&#39;,&#39;shrink&#39;: 0.5}
            )

            plt.xlabel(&#39;Brain region&#39;,fontsize=16,labelpad=20)
            plt.ylabel(&#39;Brain region&#39;,fontsize=16,labelpad=20)
            plt.title(group)
            plt.xticks(
                    np.arange(20,N_rois,20),
                    np.arange(20,N_rois,20).tolist(),
                    rotation=0
                    )
            plt.yticks(
                    np.arange(20,N_rois,20),
                    np.arange(20,N_rois,20).tolist()
                    )
            plt.tick_params(
                axis=&#39;both&#39;,         
                which=&#39;both&#39;,     
                bottom=False,
                left=False
                )
            plt.tight_layout()
            #plt.show()

    return static_fc</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.group_transitions"><code class="name flex">
<span>def <span class="ident">group_transitions</span></span>(<span>self, k=2, metric='mean', cmap='inferno', darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute and plot the mean or median transition
probabilities matrix of each group/condition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
The k-means partition of interest.</p>
<p>metric : str.
Whether to plot the 'mean' or 'median'
matrices.</p>
<p>cmap : str.
Colormap to use in the created heatmaps.</p>
<p>darkstyle : bool.
Whether to use a dark background for
plotting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_transitions(self,k=2,metric=&#39;mean&#39;,cmap=&#39;inferno&#39;,darkstyle=False):
    &#34;&#34;&#34;
    Compute and plot the mean or median transition
    probabilities matrix of each group/condition.

    Params:
    -------
    k : int.
        The k-means partition of interest.

    metric : str.
        Whether to plot the &#39;mean&#39; or &#39;median&#39;
        matrices.

    cmap : str.
        Colormap to use in the created heatmaps.

    darkstyle : bool.
        Whether to use a dark background for
        plotting.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)

    mats = group_transition_matrix(
        self._dynamics_.transitions[f&#39;k_{k}&#39;],
        metric=metric,
        cmap=cmap,
        darkstyle=darkstyle
        )

    return mats</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.load_centroids"><code class="name flex">
<span>def <span class="ident">load_centroids</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the computed clusters centroids
for a specific 'k' partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<h2 id="returns">Returns:</h2>
<p>centroids : pd.DataFrame with shape (n_centroids,n_rois).
Contains the computed centroids for
the selected k partition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_centroids(self,k=2):
    &#34;&#34;&#34;
    Return the computed clusters centroids
    for a specific &#39;k&#39; partition.

    Params:
    -------
    k : int.
        Select the partition of interest.
    
    Returns:
    -------
    centroids : pd.DataFrame with shape (n_centroids,n_rois).
        Contains the computed centroids for
        the selected k partition.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)
    centroids = pd.DataFrame(self.load_model(k=k).cluster_centers_,columns=self.rois_labels)
    return centroids</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.load_model"><code class="name flex">
<span>def <span class="ident">load_model</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Load fitted model for a specific 'k' partition.
Given that each model is an instance of the KMeansLeida
class, once loaded you can access all the object methods
and attributes.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<h2 id="returns">Returns:</h2>
<p>model : KMeansLeida instance.
The fitted model that was used to predict
the cluster labels of each observation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_model(self,k=2):
    &#34;&#34;&#34;
    Load fitted model for a specific &#39;k&#39; partition.
    Given that each model is an instance of the KMeansLeida
    class, once loaded you can access all the object methods
    and attributes.

    Params:
    -------
    k : int.
        Select the partition of interest.
    
    Returns:
    -------
    model : KMeansLeida instance.
        The fitted model that was used to predict
        the cluster labels of each observation.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)
    model = self._clustering_.models[f&#39;k_{k}&#39;]
    return model</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.occupancies"><code class="name flex">
<span>def <span class="ident">occupancies</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the computed fractional occupancy of each
phase-locking state for a specific 'k' partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Specify the K-Means partition of
interest.</p>
<h2 id="returns">Returns:</h2>
<p>occupancies : pd.DataFrame.
Contains the computed fractional occupancy
of each PL state for each subject for the
selected 'k' partition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def occupancies(self,k=2):
    &#34;&#34;&#34;
    Return the computed fractional occupancy of each
    phase-locking state for a specific &#39;k&#39; partition.

    Params:
    -------
    k : int.
        Specify the K-Means partition of
        interest.

    Returns:
    --------
    occupancies : pd.DataFrame.
        Contains the computed fractional occupancy
        of each PL state for each subject for the
        selected &#39;k&#39; partition.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)

    return self._dynamics_.occupancies[f&#39;k_{k}&#39;]</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.overlap_withyeo"><code class="name flex">
<span>def <span class="ident">overlap_withyeo</span></span>(<span>self, parcellation=None, n_areas=None, k=2, state=None, darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the overlap between the 7 resting-state
networks defined in Yeo et al. (2011) and the brain
cortical regions/parcels of the phase-locking state
of interest. The correlations are shown in a barplot,
and a dataframe with the correlations and p-values is
returned.</p>
<h2 id="params">Params:</h2>
<p>parcellation : str.
Specify path to your parcellation .nii file.
Note: the parcellation must be of 2mm resolution.</p>
<p>n_areas : None | int.
Analyze only the first n areas from the provided
parcellation.
Usefull when the parcellation contains subcortical
regions that must be ignored when computing the overlap
with Yeo's cortical networks.</p>
<p>k : int.
Select the partition.</p>
<p>state : int.
Select the PL pattern or state of
interest.</p>
<p>darkstyle : bool.
Whether to use a dark theme for the plot.</p>
<h2 id="returns">Returns:</h2>
<p>overlap : pandas.dataframe with shape (7networks,3).
Contains the correlation coefficient (and p-value)
between the selected phase-locking state and each
of the 7 resting-state networks from Yeo (2011).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overlap_withyeo(self,parcellation=None,n_areas=None,k=2,state=None,darkstyle=False):
    &#34;&#34;&#34;
    Compute the overlap between the 7 resting-state
    networks defined in Yeo et al. (2011) and the brain
    cortical regions/parcels of the phase-locking state
    of interest. The correlations are shown in a barplot,
    and a dataframe with the correlations and p-values is
    returned.

    Params:
    --------
    parcellation : str.
        Specify path to your parcellation .nii file.
        Note: the parcellation must be of 2mm resolution.

    n_areas : None | int.
        Analyze only the first n areas from the provided
        parcellation. 
        Usefull when the parcellation contains subcortical
        regions that must be ignored when computing the overlap
        with Yeo&#39;s cortical networks.

    k : int.
        Select the partition.

    state : int.
        Select the PL pattern or state of
        interest.

    darkstyle : bool.
        Whether to use a dark theme for the plot.

    Returns:
    --------
    overlap : pandas.dataframe with shape (7networks,3).
        Contains the correlation coefficient (and p-value)
        between the selected phase-locking state and each
        of the 7 resting-state networks from Yeo (2011).
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)
    _check_state(k,state)

    centr = {}

    for k_ in range(self._K_min_,self._K_max_+1):
        cent = self.load_centroids(k_)
        cent.insert(0,&#39;state&#39;,[i+1 for i in range(cent.shape[0])])
        cent.insert(0,&#39;k&#39;,k_)
        centr[f&#39;k{k_}&#39;] = cent
    
    centr = pd.concat(centr,ignore_index=True)

    corr,pvals = rsnets.compute_overlap(
        centr,
        parcellation=parcellation,
        n_areas=n_areas
        )

    overlap = rsnets.state_overlap(
        corr,
        pvals,
        k=k,
        state=state,
        plot=True,
        darkstyle=darkstyle
        )

    return overlap</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.plot_clustering_performance"><code class="name flex">
<span>def <span class="ident">plot_clustering_performance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 2x2 panel with lineplots showing
the clustering evaluation metrics for each
k partition explored (Dunn score, distortion,
silhouette score, and Davis-Bouldin score).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_clustering_performance(self):
    &#34;&#34;&#34;
    Create a 2x2 panel with lineplots showing
    the clustering evaluation metrics for each
    k partition explored (Dunn score, distortion,
    silhouette score, and Davis-Bouldin score).
    &#34;&#34;&#34;
    self._check_is_fitted()
    plot_clustering_scores(self._clustering_.performance)</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.plot_clusters3D"><code class="name flex">
<span>def <span class="ident">plot_clusters3D</span></span>(<span>self, k=2, clusters_colors=None, grid=True, alpha=0.7, dot_size=3, edgecolor=None, darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Visualize the identified clusters (BOLD phase-locking
states) in a 3D scatter plot, which constitutes a
low-dimensional representation of the 'state space'.
Method : take the eigenvectors and extract the first
three principal components to reduce the dimensionality
of the data to a 3D space. Each dot in the plot thus
represents a single eigenvector, and is coloured according
to the cluster it belongs to.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Specify the partition to plot.</p>
<p>clusters_colors : list (optional).
Provide a list with the desired color
of each cluster. If not provided, then
a predefined set of colors will be used.</p>
<p>grid : bool.
Whether to show grid or not.</p>
<p>alpha : float.
Set transparency of dots.</p>
<p>dot_size : float.
Select the dot size.</p>
<p>edge_color : None | str.
Specify an edge color to use
on dots.</p>
<p>darkstyle : bool.
Whether to use a dark theme for
the plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_clusters3D(self,k=2,clusters_colors=None,grid=True,alpha=.7,dot_size=3,edgecolor=None,darkstyle=False):
    &#34;&#34;&#34;
    Visualize the identified clusters (BOLD phase-locking
    states) in a 3D scatter plot, which constitutes a
    low-dimensional representation of the &#39;state space&#39;. 
    Method : take the eigenvectors and extract the first
    three principal components to reduce the dimensionality
    of the data to a 3D space. Each dot in the plot thus
    represents a single eigenvector, and is coloured according
    to the cluster it belongs to.
    
    Params:
    -------
    k : int.
        Specify the partition to plot.

    clusters_colors : list (optional). 
        Provide a list with the desired color
        of each cluster. If not provided, then
        a predefined set of colors will be used.

    grid : bool. 
        Whether to show grid or not.

    alpha : float. 
        Set transparency of dots.

    dot_size : float. 
        Select the dot size.

    edge_color : None | str.
        Specify an edge color to use
        on dots.

    darkstyle : bool.
        Whether to use a dark theme for
        the plot.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)

    X = np.array(self.eigenvectors.iloc[:,2:], dtype=np.float32) #keep array containing only the eigenvectors
    y = self._clustering_.predictions[f&#39;k_{k}&#39;].values #keep 1D array with the labels of each eigenvector

    with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
        plot_clusters3D(
            X,
            y,
            clusters_colors=clusters_colors,
            grid=grid,
            alpha=alpha,
            dot_size=dot_size,
            edgecolor=edgecolor
            )</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.plot_pvalues"><code class="name flex">
<span>def <span class="ident">plot_pvalues</span></span>(<span>self, metric='occupancies', conditions=None, darkstyle=False, fill_areas=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a scatter plot showing the p-values
obtained by the statistical analysis of a given
'metric' across the explored 'k' range.</p>
<h2 id="params">Params:</h2>
<p>metric : str.
Specify the metric of interest
('occupancies','dwell_times','transitions').</p>
<p>conditions : None | list. Optional
(Usefull only when your data contains more
than two conditions). You can provide a list
specifying only two conditions of interest to
plot. Otherwise create a plot for each pair of
conditions. </p>
<p>darkstyle : bool.
Whether to use a dark theme for
the plots.</p>
<p>fill_areas : bool.
Select whether to fill the significance
areas with color.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pvalues(self,metric=&#39;occupancies&#39;,conditions=None,darkstyle=False,fill_areas=True):
    &#34;&#34;&#34;
    Create a scatter plot showing the p-values
    obtained by the statistical analysis of a given
    &#39;metric&#39; across the explored &#39;k&#39; range.

    Params:
    -------
    metric : str. 
        Specify the metric of interest
        (&#39;occupancies&#39;,&#39;dwell_times&#39;,&#39;transitions&#39;).

    conditions : None | list. Optional
        (Usefull only when your data contains more
        than two conditions). You can provide a list
        specifying only two conditions of interest to
        plot. Otherwise create a plot for each pair of
        conditions. 

    darkstyle : bool.
        Whether to use a dark theme for
        the plots.

    fill_areas : bool.
        Select whether to fill the significance
        areas with color.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_metric(metric)

    if not isinstance(fill_areas,bool) or not isinstance(darkstyle,bool):
        raise TypeError(&#34;&#39;fill_areas&#39; and &#39;darkstyle&#39; must be True or False!&#34;)

    if conditions is not None:
        if not isinstance(conditions,list) or len(conditions)!=2:
            raise Exception(&#34;If provided, &#39;conditions&#39; must be a list with two items.&#34;)
        for cond in conditions:
            if cond not in self._classes_lst_:
                raise Exception(f&#34;&#39;{cond}&#39; was not founded in the data. &#34;
                                f&#34; Valid options are: {self._classes_lst_}&#34;)
    else:
        conditions = self._classes_lst_.copy()

    pooled_stats = self._pool_stats(metric=metric)

    for cond in combinations(conditions,2):
        pooled_stats_ = pooled_stats[
                (pooled_stats.group_1.isin(cond))
                &amp;
                (pooled_stats.group_2.isin(cond))
                ].reset_index(drop=True)

        scatter_pvalues(pooled_stats_,metric=metric,darkstyle=darkstyle,fill_areas=fill_areas)</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.plot_states_in_bold"><code class="name flex">
<span>def <span class="ident">plot_states_in_bold</span></span>(<span>self, subject_id, k=2, alpha=0.5, darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create plot showing the time-series of BOLD signals,
highlighting the dominant phase-locking (PL) state
of each time point or volume.</p>
<h2 id="params">Params:</h2>
<p>subject_id : str.
Specify the 'id' of the subject
of interest.</p>
<p>k : int.
Select the k partition.</p>
<p>alpha : float.
Transparency of the colors that
show the dominant PL pattern of
each time point.</p>
<p>darkstyle : bool.
Whether to create the plot using
a darkstyle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_in_bold(self,subject_id,k=2,alpha=.5,darkstyle=False):
    &#34;&#34;&#34;
    Create plot showing the time-series of BOLD signals, 
    highlighting the dominant phase-locking (PL) state
    of each time point or volume.

    Params:
    -------
    subject_id : str.
        Specify the &#39;id&#39; of the subject
        of interest.

    k : int.
        Select the k partition.

    alpha : float.
        Transparency of the colors that
        show the dominant PL pattern of
        each time point.

    darkstyle : bool.
        Whether to create the plot using
        a darkstyle.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)
    tseries = self.time_series[subject_id][:,1:-1] #get subject signals (excluding the 1st and last volumes)
    predictions = self._clustering_.predictions
    y = predictions[predictions.subject_id==subject_id][f&#39;k_{k}&#39;].values #get predictions for selected k.

    with plt.style.context(&#34;dark_background&#34; if darkstyle else &#34;default&#34;):
        states_in_bold(tseries,y,alpha=alpha)</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.plot_states_matrices"><code class="name flex">
<span>def <span class="ident">plot_states_matrices</span></span>(<span>self, k=2, cmap='jet', darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Take the controids resulting from the k-means
clustering (i.e., the phase-locking states) and
reconstruct the connectivity patterns in matrix
format.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Specify the K partition of interest.</p>
<p>cmap : str. Default = 'jet'.
Select the colormap to use.</p>
<p>darkstyle : bool.
Whether to use a black background.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_matrices(self,k=2,cmap=&#39;jet&#39;,darkstyle=False):
    &#34;&#34;&#34;
    Take the controids resulting from the k-means
    clustering (i.e., the phase-locking states) and
    reconstruct the connectivity patterns in matrix
    format.

    Params:
    -------
    k : int.
        Specify the K partition of interest.
    
    cmap : str. Default = &#39;jet&#39;.
        Select the colormap to use.

    darkstyle : bool.
        Whether to use a black background.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)

    if not isinstance(cmap,str):
        raise TypeError(&#34;&#39;cmap&#39; must be a string!&#34;)
    if not isinstance(darkstyle,bool):
        raise TypeError(&#34;&#39;darkstyle&#39; must be True or False!&#34;)

    _ = centroid2matrix(
        self.load_centroids(k).values,
        plot=True,
        cmap=cmap,
        darkstyle=darkstyle
        )</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.plot_states_network"><code class="name flex">
<span>def <span class="ident">plot_states_network</span></span>(<span>self, k=2, state=1, node_size=8, node_color='infer', linewidth=3, open=True, save=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 3D interactive figure embedded in a
.html file showing the BOLD phase-locking (PL)
states as a connected network. All the ROIs/parcels
that belong to the selected phase-locking state are
connected between each other.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<p>state : int or str.
Use an integer to plot a single
PL state of interest, or 'all'
to plot all the PL states of the
selected K partition.</p>
<p>node_size : int.
Select the size of the nodes.</p>
<p>node_color : str.
Select the color of the nodes. If
'infer', then the nodes participating
in the PL states are colored red and
the rest blue. If 'black', then all the
nodes are colored in the same way.</p>
<p>linewidth : int.
Select the size of the edges
connecting the nodes.</p>
<p>open : bool.
Whether to open the plots in web
browser. If False, you can open the
figures using the '.open_in_browser()'
method of the returned object/s.</p>
<p>save : bool.
Whether to save each plot in a
.html file. If True, the files
are saved in 'LEiDA_results/brain_plots'.</p>
<h2 id="returns">Returns:</h2>
<p>plot/s : dict or single figure.
If state='all', return a dictionary
that contains the constructed plots.
They can be opened or saved using
'.open()' and '.save_as_html(path)',
respectively. If state=int, then return
a single figure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_network(self,k=2,state=1,node_size=8,node_color=&#39;infer&#39;,linewidth=3,open=True,save=False):
    &#34;&#34;&#34;
    Create a 3D interactive figure embedded in a
    .html file showing the BOLD phase-locking (PL)
    states as a connected network. All the ROIs/parcels
    that belong to the selected phase-locking state are
    connected between each other.

    Params:
    -------
    k : int.
        Select the partition of interest.

    state : int or str.
        Use an integer to plot a single
        PL state of interest, or &#39;all&#39;
        to plot all the PL states of the
        selected K partition.

    node_size : int. 
        Select the size of the nodes.

    node_color : str. 
        Select the color of the nodes. If
        &#39;infer&#39;, then the nodes participating
        in the PL states are colored red and
        the rest blue. If &#39;black&#39;, then all the
        nodes are colored in the same way.

    linewidth : int. 
        Select the size of the edges
        connecting the nodes.

    open : bool. 
        Whether to open the plots in web
        browser. If False, you can open the
        figures using the &#39;.open_in_browser()&#39;
        method of the returned object/s.

    save : bool.
        Whether to save each plot in a
        .html file. If True, the files
        are saved in &#39;LEiDA_results/brain_plots&#39;.

    Returns:
    --------
    plot/s : dict or single figure.
        If state=&#39;all&#39;, return a dictionary
        that contains the constructed plots.
        They can be opened or saved using
        &#39;.open()&#39; and &#39;.save_as_html(path)&#39;,
        respectively. If state=int, then return
        a single figure.
    &#34;&#34;&#34;
    if self.rois_coordinates is None:
        raise Exception(&#34;You can&#39;t create this plot because the &#34;
                        &#34;ROI&#39;s coordinates could&#39;t be loaded.&#34;)
    
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)

    if not isinstance(state,(int,str)):
        raise TypeError(&#34;&#39;state&#39; must be either &#39;all&#39; or an integer &#34;
                        &#34;specifying the number of a particular PL state.&#34;)
    if isinstance(state,str):
        if state!=&#39;all&#39;:
            raise ValueError(&#34;If a string is provided, &#39;state&#39; must be &#39;all&#39;!&#34;)
    else:
        _check_state(k,state)

    centroids = self.load_centroids(k=k).values #load centroids for the selected k

    #plotting
    plot = brain_states_network(
        centroids,
        self.rois_coordinates,
        state=state,
        node_size=node_size,
        node_color=node_color,
        linewidth=linewidth,
        open=open,
        )

    #saving figures
    if save:
        _save_html(self._results_path_,plot,k,state,plot_type=&#39;network&#39;)
        
    return plot</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.plot_states_network_glass"><code class="name flex">
<span>def <span class="ident">plot_states_network_glass</span></span>(<span>self, k=2, darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a glass brain (axial view) showing the
network representation of each phase-locking
(PL) state for the selected 'k' partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<p>darkstyle : bool.
Whether to use a dark theme for
the plots.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_network_glass(self,k=2,darkstyle=False):
    &#34;&#34;&#34;
    Create a glass brain (axial view) showing the
    network representation of each phase-locking
    (PL) state for the selected &#39;k&#39; partition.

    Params:
    -------
    k : int.
        Select the partition of interest.

    darkstyle : bool.
        Whether to use a dark theme for
        the plots.
    &#34;&#34;&#34;
    if self.rois_coordinates is None:
        raise Exception(&#34;You can&#39;t create this plot because the ROI&#39;s coordinates could&#39;t be loaded.&#34;)

    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)

    pl_states = self.load_centroids(k=k).values

    with plt.style.context(&#34;dark_background&#34; if darkstyle else &#34;default&#34;):
        states_k_glass(pl_states,self.rois_coordinates,darkstyle=darkstyle)</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.plot_states_nodes"><code class="name flex">
<span>def <span class="ident">plot_states_nodes</span></span>(<span>self, k=2, state=1, node_size=15, show_labels=True, open=True, save=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 3D interactive figure embedded in a
.html file showing the BOLD phase-locking (PL)
states in anatomical MNI space. Each parcel/ROI
is represented as a node. Nodes that are part of
the PL pattern are coloured in red, and the rest
of nodes are coloured in blue.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<p>state : int or str.
Use an integer to plot a single
PL state of interest, or 'all'
to plot all the PL states of the
selected K partition.</p>
<p>node_size: int or float.
Define the size of the nodes. Nodes
that don't belong to the pattern are
plotted smaller.</p>
<p>show_labels : bool.
Whether to show each ROI label.</p>
<p>open : bool.
Whether to open the plots in web
browser. If False, you can open the
figures using the '.open_in_browser()'
method of the returned object/s.</p>
<p>save : bool.
Whether to save each plot in a
.html file. If True, the files
are saved in 'LEiDA_results/brain_plots'.</p>
<h2 id="returns">Returns:</h2>
<p>plot/s : dict or single figure.
If state='all', return a dictionary
that contains the constructed plots.
They can be opened or saved using
'.open()' and '.save_as_html(path)',
respectively. If state=int, then return
a single figure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_nodes(self,k=2,state=1,node_size=15,show_labels=True,open=True,save=False):
    &#34;&#34;&#34;
    Create a 3D interactive figure embedded in a
    .html file showing the BOLD phase-locking (PL)
    states in anatomical MNI space. Each parcel/ROI
    is represented as a node. Nodes that are part of
    the PL pattern are coloured in red, and the rest
    of nodes are coloured in blue.

    Params:
    -------
    k : int.
        Select the partition of interest.

    state : int or str.
        Use an integer to plot a single
        PL state of interest, or &#39;all&#39;
        to plot all the PL states of the
        selected K partition.

    node_size: int or float.
        Define the size of the nodes. Nodes
        that don&#39;t belong to the pattern are
        plotted smaller.

    show_labels : bool.
        Whether to show each ROI label.

    open : bool. 
        Whether to open the plots in web
        browser. If False, you can open the
        figures using the &#39;.open_in_browser()&#39;
        method of the returned object/s.

    save : bool.
        Whether to save each plot in a
        .html file. If True, the files
        are saved in &#39;LEiDA_results/brain_plots&#39;.

    Returns:
    --------
    plot/s : dict or single figure.
        If state=&#39;all&#39;, return a dictionary
        that contains the constructed plots.
        They can be opened or saved using
        &#39;.open()&#39; and &#39;.save_as_html(path)&#39;,
        respectively. If state=int, then return
        a single figure.
    &#34;&#34;&#34;
    self._check_is_fitted()
    if self.rois_coordinates is None:
        raise Exception(&#34;You can&#39;t create this plot because the &#34;
                        &#34;ROI&#39;s coordinates could&#39;t be loaded.&#34;)

    _check_k_input(self._K_min_,self._K_max_,k)
    centroids = self.load_centroids(k=k).values
    plots = brain_states_nodes(
        centroids,
        self.rois_coordinates,
        node_size=node_size,
        state=state,
        nodes_labels=None if not show_labels else self.rois_labels,
        open=open
        )

    if save:
        _save_html(self._results_path_,plots,k,state,plot_type=&#39;nodes&#39;)

    return plots</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.plot_states_on_surf"><code class="name flex">
<span>def <span class="ident">plot_states_on_surf</span></span>(<span>self, k=2, state='all', parcellation=None, discretize=True, cmap='auto', darkstyle=False, open=False, save=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 3D interactive figure embedded in a
.html file showing the BOLD phase-locking (PL)
states on cortical surface. By default, all the
cortical regions that belong to a given PL state
or pattern are coloured in red(s), while the rest
of cortical regions are coloured in blue(s). You
can change the colormap throught the 'cmap' argument.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Partition of interest.</p>
<p>state : str or int.
Whether to plot 'all' the PL states of
the selected partition or a single state
of interest.</p>
<p>parcellation : str.
Path to the .nii file containing the
parcellation from which the time series
were extracted.</p>
<p>discretize : bool. Default = True.
Whether to plot the raw values of the
phase-locking state/centroid, or plot
all the brain regions that belong to
the phase-locking state with the same
intensity.</p>
<p>cmap : str or matplotlib colormap, optional. Default = 'auto'.
Colormap to use in the brain plot.
If 'auto', then the brain regions that
belong to the phase-locking state will
be coloured in red(s), and the rest of
regions in blue(s).</p>
<p>darkstyle : bool.
Whether to use a black background.</p>
<p>open : bool.
Whether to open the plots in web
browser. If False, you can open the
figures using the '.open_in_browser()'
method of the returned object/s.</p>
<p>save : bool.
Whether to save each plot in a
.html file. If True, the files
are saved in 'LEiDA_results/brain_plots'.</p>
<h2 id="returns">Returns:</h2>
<p>g : SurfaceView or dictionarity of SurfaceViews.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_on_surf(self,k=2,state=&#39;all&#39;,parcellation=None,discretize=True,cmap=&#39;auto&#39;,darkstyle=False,open=False,save=False):
    &#34;&#34;&#34;
    Create a 3D interactive figure embedded in a
    .html file showing the BOLD phase-locking (PL)
    states on cortical surface. By default, all the
    cortical regions that belong to a given PL state
    or pattern are coloured in red(s), while the rest
    of cortical regions are coloured in blue(s). You
    can change the colormap throught the &#39;cmap&#39; argument.

    Params:
    -------
    k : int.
        Partition of interest.

    state : str or int.
        Whether to plot &#39;all&#39; the PL states of
        the selected partition or a single state
        of interest.

    parcellation : str.
        Path to the .nii file containing the
        parcellation from which the time series
        were extracted.

    discretize : bool. Default = True.
        Whether to plot the raw values of the
        phase-locking state/centroid, or plot
        all the brain regions that belong to
        the phase-locking state with the same
        intensity.

    cmap : str or matplotlib colormap, optional. Default = &#39;auto&#39;.
        Colormap to use in the brain plot.
        If &#39;auto&#39;, then the brain regions that
        belong to the phase-locking state will
        be coloured in red(s), and the rest of
        regions in blue(s).

    darkstyle : bool.
        Whether to use a black background.

    open : bool. 
        Whether to open the plots in web
        browser. If False, you can open the
        figures using the &#39;.open_in_browser()&#39;
        method of the returned object/s.

    save : bool.
        Whether to save each plot in a
        .html file. If True, the files
        are saved in &#39;LEiDA_results/brain_plots&#39;.

    Returns:
    --------
    g : SurfaceView or dictionarity of SurfaceViews. 
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)

    if not isinstance(state,(int,str)):
        raise TypeError(&#34;&#39;state&#39; must be either &#39;all&#39; or an integer &#34;
                        &#34;specifying the number of a particular PL state&#34;)
    if isinstance(state,str):
        if state!=&#39;all&#39;:
            raise ValueError(&#34;If a string is provided, &#39;state&#39; must be &#39;all&#39;!&#34;)
    else:
        _check_state(k,state)

    centroids = self.load_centroids(k=k).values 
    if state!=&#39;all&#39;:
        centroids = centroids[state-1,:]
    
    g = brain_states_on_surf(
        centroids,
        parcellation=parcellation,
        black_bg=darkstyle,
        open=open,
        discretize=discretize,
        cmap=cmap
        )

    if save:
        _save_html(self._results_path_,g,k,state,plot_type=&#39;surface&#39;)

    return g</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.plot_states_on_surf2"><code class="name flex">
<span>def <span class="ident">plot_states_on_surf2</span></span>(<span>self, k=2, state=1, parcellation=None, surface='pial', hemi='right', view='lateral', darkstyle=False, save=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a BOLD phase-locking state of interest
on cortical surface mesh. </p>
<h2 id="params">Params:</h2>
<p>k : int.
Partition of interest.</p>
<p>state : int.
Select the PL state/pattern of
interest.</p>
<p>parcellation : str.
Path to the .nii file containing
the parcellation from which the
signals were extracted.</p>
<p>surface : str.
Specify the surface type to plot
the pattern on. Valid options are
'pial','infl', and 'white'.</p>
<p>hemi : str.
Select the hemisphere to plot.
Valid options are 'right', 'left',
or 'both'.</p>
<p>view : str
View of the surface that is rendered.
Default='lateral'. Options = {'lateral',
'medial', 'dorsal', 'ventral', 'anterior',
'posterior'}. If 'hemi'='both', then 'dorsal'
and 'lateral' views are displayed.</p>
<p>darkstyle : bool
Whether to use a black background.</p>
<p>save : bool.
Whether to save the created figure in
local folder. If True, the files are
saved in 'LEiDA_results/brain_plots',
and the plot will not be displayed.</p>
<h2 id="returns">Returns:</h2>
<p>g : matplotlib figure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_on_surf2(self,k=2,state=1,parcellation=None,surface=&#39;pial&#39;,hemi=&#39;right&#39;,view=&#39;lateral&#39;,darkstyle=False,save=False):
    &#34;&#34;&#34;
    Plot a BOLD phase-locking state of interest 
    on cortical surface mesh. 

    Params:
    -------
    k : int.
        Partition of interest.

    state : int.
        Select the PL state/pattern of
        interest.

    parcellation : str.
        Path to the .nii file containing
        the parcellation from which the
        signals were extracted.

    surface : str.
        Specify the surface type to plot
        the pattern on. Valid options are
        &#39;pial&#39;,&#39;infl&#39;, and &#39;white&#39;.

    hemi : str.
        Select the hemisphere to plot.
        Valid options are &#39;right&#39;, &#39;left&#39;,
        or &#39;both&#39;.

    view : str
        View of the surface that is rendered. 
        Default=&#39;lateral&#39;. Options = {&#39;lateral&#39;,
        &#39;medial&#39;, &#39;dorsal&#39;, &#39;ventral&#39;, &#39;anterior&#39;,
        &#39;posterior&#39;}. If &#39;hemi&#39;=&#39;both&#39;, then &#39;dorsal&#39;
        and &#39;lateral&#39; views are displayed.

    darkstyle : bool
        Whether to use a black background.

    save : bool.
        Whether to save the created figure in
        local folder. If True, the files are
        saved in &#39;LEiDA_results/brain_plots&#39;,
        and the plot will not be displayed.

    Returns:
    --------
    g : matplotlib figure. 
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)
    _check_state(k,state)

    centroids = self.load_centroids(k=k).values 
    centroid = centroids[state-1,:]

    if save: 
        path = f&#39;{self._results_path_}/brain_plots&#39;
        if not os.path.exists(path): 
            os.makedirs(path)
    #plotting
    print(&#34;\n-Creating plot. This may take &#34;
        &#34;some minutes. Please wait...&#34;)

    with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
        g = brain_states_on_surf2(
            centroid,
            parcellation=parcellation,
            hemi=hemi,
            surface=surface,
            view=view
            )
    
    if save:
        try:
            filename = f&#34;{path}/K{k}_PL_state_{state}_{surface}surf_{hemi}hemi_{view if hemi!=&#39;both&#39; else &#39;multiview&#39;}{&#39;_dark&#39; if darkstyle else &#39;&#39;}.png&#34;
            g.savefig(filename,dpi=300)
            plt.close()
            del g
            print(f&#34;The plot was save at: {filename}&#34;)
        except:
            raise Exception(&#34;An error occured when saving the plot.&#34;)
    else:
        return g</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.plot_states_pyramid"><code class="name flex">
<span>def <span class="ident">plot_states_pyramid</span></span>(<span>self, metric='occupancies', conditions=None, despine=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a pyramid of barplots showing the 'metric'
of interest for each group, cluster (PL state), and
K partition. Each barplot (which represents a particular
PL state) is coloured according to its associated p-value:
-black: the p-value is higher than 0.05.
-red: the p-value is lower than 0.05 but higher than 0.05 / k.
-green: the p-value is lower than 0.05/k but higher than 0.05 / (k).
-blue: the p-value is lower than 0.05 / (k).</p>
<h2 id="params">Params:</h2>
<p>metric : str.
Select the dynamical systems theory metric
of interest (either 'occupancies' or 'dwell_times').</p>
<p>conditions : None | list. Optional.
(Usefull only when your data contains more
than two conditions). You can provide a list
specifying only two conditions of interest to
plot. Otherwise create a plot for each pair of
conditions. </p>
<p>despine : bool. Default = True.
Whether to despine top and right axes of the
subplots.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_pyramid(self,metric=&#39;occupancies&#39;,conditions=None,despine=True):
    &#34;&#34;&#34;
    Create a pyramid of barplots showing the &#39;metric&#39;
    of interest for each group, cluster (PL state), and
    K partition. Each barplot (which represents a particular
    PL state) is coloured according to its associated p-value:
    -black: the p-value is higher than 0.05.
    -red: the p-value is lower than 0.05 but higher than 0.05 / k.
    -green: the p-value is lower than 0.05/k but higher than 0.05 / (k).
    -blue: the p-value is lower than 0.05 / (k).

    Params:
    -------
    metric : str.
        Select the dynamical systems theory metric
        of interest (either &#39;occupancies&#39; or &#39;dwell_times&#39;).

    conditions : None | list. Optional.
        (Usefull only when your data contains more
        than two conditions). You can provide a list
        specifying only two conditions of interest to
        plot. Otherwise create a plot for each pair of
        conditions. 

    despine : bool. Default = True.
        Whether to despine top and right axes of the
        subplots.
    &#34;&#34;&#34;
    self._check_is_fitted
    _check_metric(metric)

    if conditions is not None:
        if not isinstance(conditions,list) or len(conditions)!=2:
            raise Exception(&#34;If provided, &#39;conditions&#39; must be a list with two items.&#34;)
        for cond in conditions:
            if cond not in self._classes_lst_:
                raise Exception(f&#34;&#39;{cond}&#39; was not founded in the data. &#34;
                                f&#34; Valid options are: {self._classes_lst_}&#34;)
    else:
        conditions = self._classes_lst_.copy()

    pooled_stats = self._pool_stats(metric=metric)

    for cond in combinations(conditions,2):
        pooled_stats_ = pooled_stats[
                (pooled_stats.group_1.isin(cond))
                &amp;
                (pooled_stats.group_2.isin(cond))
                ].reset_index(drop=True)

        dyn_metric = self._dynamics_[metric]
        dyn_metric = {k:v[v.condition.isin(conditions)] for k,v in dyn_metric.items()}

        plot_pyramid(
            dyn_metric,
            pooled_stats_,
            K_min=self._K_min_,
            K_max=self._K_max_,
            despine=despine
            )</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.plot_voronoi_cells"><code class="name flex">
<span>def <span class="ident">plot_voronoi_cells</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the clusters centroids in a 2D Voronoi
cells space. Performs a PCA to reduce the
dimensionality of the original centroid space
to a 2D space.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the clustering solution to plot.</p>
<p>Note: see Vohryzek, Deco et al. (2020) p.4</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_voronoi_cells(self,k=2):
    &#34;&#34;&#34;
    Plot the clusters centroids in a 2D Voronoi
    cells space. Performs a PCA to reduce the
    dimensionality of the original centroid space
    to a 2D space.

    Params:
    --------
    k : int.
        Select the clustering solution to plot.

    Note: see Vohryzek, Deco et al. (2020) p.4
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)

    centroids = self.load_centroids(k=k).values 
    plot_voronoi(centroids)</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.significant_states"><code class="name flex">
<span>def <span class="ident">significant_states</span></span>(<span>self, metric='occupancies')</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dataframe containing only the statistics
of the phase-locking states that are significantly
different between groups.</p>
<h2 id="params">Params:</h2>
<p>metric : str.
Metric of interest (Options: 'occupancies',
'dwell_times').</p>
<h2 id="returns">Returns:</h2>
<p>stats : pandas.dataframe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def significant_states(self,metric=&#34;occupancies&#34;):
    &#34;&#34;&#34;
    Return a dataframe containing only the statistics
    of the phase-locking states that are significantly
    different between groups.

    Params:
    -------
    metric : str.
        Metric of interest (Options: &#39;occupancies&#39;,
        &#39;dwell_times&#39;).

    Returns:
    --------
    stats : pandas.dataframe.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_metric(metric)

    stats = self._pool_stats(metric=metric)
    has_results = True if stats[stats.reject_null==True].shape[0]&gt;=1 else False #check if some result was significant
    if has_results:
        return stats[stats.reject_null==True]
    else:
        print(&#34;No significant results were founded.&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.state_rois"><code class="name flex">
<span>def <span class="ident">state_rois</span></span>(<span>self, k=2, state=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list with the names of the ROIs/parcels that
participates in a specific phase-locking (PL) state.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition.</p>
<p>state : int.
Select the PL pattern or state of
interest.</p>
<h2 id="returns">Returns:</h2>
<p>rois : list.
Contains the names of the ROIs that
are part of the selected PL state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def state_rois(self,k=2,state=1):
    &#34;&#34;&#34;
    Get a list with the names of the ROIs/parcels that
    participates in a specific phase-locking (PL) state.

    Params:
    -------
    k : int.
        Select the partition.

    state : int.
        Select the PL pattern or state of
        interest.

    Returns:
    --------
    rois : list.
        Contains the names of the ROIs that
        are part of the selected PL state.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)
    _check_state(k,state)

    data_k = self.load_centroids(k=k).iloc[state-1,:].reset_index()
    data_k.columns = [&#39;rois&#39;,&#39;value&#39;]
    rois = list(data_k[data_k.value&gt;0][&#39;rois&#39;])
    return rois</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.stats"><code class="name flex">
<span>def <span class="ident">stats</span></span>(<span>self, k=2, metric='occupancies')</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the results from the statistical analysis of
a 'metric' of interest ('occupancies' or 'dwell_times')
for a specific 'k' partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the 'k' partition of interest.</p>
<p>metric : str.
Select the metric to retrieve results.</p>
<h2 id="returns">Returns:</h2>
<p>stats : pandas.dataframe.
Results of the statistical analysis
of each PL state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stats(self,k=2,metric=&#39;occupancies&#39;):
    &#34;&#34;&#34;
    Retrieve the results from the statistical analysis of 
    a &#39;metric&#39; of interest (&#39;occupancies&#39; or &#39;dwell_times&#39;)
    for a specific &#39;k&#39; partition.

    Params:
    -------
    k : int.
        Select the &#39;k&#39; partition of interest.

    metric : str.
        Select the metric to retrieve results.

    Returns:
    --------
    stats : pandas.dataframe.
        Results of the statistical analysis
        of each PL state.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)
    _check_metric(metric)

    df_stats = self._dynamics_.stats[metric][f&#39;k_{k}&#39;]
    return df_stats</code></pre>
</details>
</dd>
<dt id="pyleida._leida.Leida.transitions"><code class="name flex">
<span>def <span class="ident">transitions</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the computed transition probabilities between
phase-locking states for a specific 'k' partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Specify the K-Means partition of interest.</p>
<h2 id="returns">Returns:</h2>
<p>transitions : pd.DataFrame.
Contains the computed transition probabilities
between PL states for each subject for the selected
'k' partition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transitions(self,k=2):
    &#34;&#34;&#34;
    Return the computed transition probabilities between
    phase-locking states for a specific &#39;k&#39; partition.

    Params:
    -------
    k : int.
        Specify the K-Means partition of interest.

    Returns:
    --------
    transitions : pd.DataFrame.
        Contains the computed transition probabilities
        between PL states for each subject for the selected
        &#39;k&#39; partition.
    &#34;&#34;&#34;
    self._check_is_fitted()
    _check_k_input(self._K_min_,self._K_max_,k)

    return self._dynamics_.transitions[f&#39;k_{k}&#39;]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyleida" href="index.html">pyleida</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyleida._leida.Leida" href="#pyleida._leida.Leida">Leida</a></code></h4>
<ul class="">
    <li><code><a title="pyleida._leida.Leida.fit_predict" href="#pyleida._leida.Leida.fit_predict">fit_predict</a></code></li>
<li><code><a title="pyleida._leida.Leida.barplot_centroids" href="#pyleida._leida.Leida.barplot_centroids">barplot_centroids</a></code></li>
<li><code><a title="pyleida._leida.Leida.centroids_distances" href="#pyleida._leida.Leida.centroids_distances">centroids_distances</a></code></li>
<li><code><a title="pyleida._leida.Leida.dwell_times" href="#pyleida._leida.Leida.dwell_times">dwell_times</a></code></li>
<li><code><a title="pyleida._leida.Leida.explore_state" href="#pyleida._leida.Leida.explore_state">explore_state</a></code></li>
<li><code><a title="pyleida._leida.Leida.group_static_fc" href="#pyleida._leida.Leida.group_static_fc">group_static_fc</a></code></li>
<li><code><a title="pyleida._leida.Leida.group_transitions" href="#pyleida._leida.Leida.group_transitions">group_transitions</a></code></li>
<li><code><a title="pyleida._leida.Leida.load_centroids" href="#pyleida._leida.Leida.load_centroids">load_centroids</a></code></li>
<li><code><a title="pyleida._leida.Leida.load_model" href="#pyleida._leida.Leida.load_model">load_model</a></code></li>
<li><code><a title="pyleida._leida.Leida.occupancies" href="#pyleida._leida.Leida.occupancies">occupancies</a></code></li>
<li><code><a title="pyleida._leida.Leida.overlap_withyeo" href="#pyleida._leida.Leida.overlap_withyeo">overlap_withyeo</a></code></li>
<li><code><a title="pyleida._leida.Leida.plot_clustering_performance" href="#pyleida._leida.Leida.plot_clustering_performance">plot_clustering_performance</a></code></li>
<li><code><a title="pyleida._leida.Leida.plot_clusters3D" href="#pyleida._leida.Leida.plot_clusters3D">plot_clusters3D</a></code></li>
<li><code><a title="pyleida._leida.Leida.plot_pvalues" href="#pyleida._leida.Leida.plot_pvalues">plot_pvalues</a></code></li>
<li><code><a title="pyleida._leida.Leida.plot_states_in_bold" href="#pyleida._leida.Leida.plot_states_in_bold">plot_states_in_bold</a></code></li>
<li><code><a title="pyleida._leida.Leida.plot_states_matrices" href="#pyleida._leida.Leida.plot_states_matrices">plot_states_matrices</a></code></li>
<li><code><a title="pyleida._leida.Leida.plot_states_network" href="#pyleida._leida.Leida.plot_states_network">plot_states_network</a></code></li>
<li><code><a title="pyleida._leida.Leida.plot_states_network_glass" href="#pyleida._leida.Leida.plot_states_network_glass">plot_states_network_glass</a></code></li>
<li><code><a title="pyleida._leida.Leida.plot_states_nodes" href="#pyleida._leida.Leida.plot_states_nodes">plot_states_nodes</a></code></li>
<li><code><a title="pyleida._leida.Leida.plot_states_on_surf" href="#pyleida._leida.Leida.plot_states_on_surf">plot_states_on_surf</a></code></li>
<li><code><a title="pyleida._leida.Leida.plot_states_on_surf2" href="#pyleida._leida.Leida.plot_states_on_surf2">plot_states_on_surf2</a></code></li>
<li><code><a title="pyleida._leida.Leida.plot_states_pyramid" href="#pyleida._leida.Leida.plot_states_pyramid">plot_states_pyramid</a></code></li>
<li><code><a title="pyleida._leida.Leida.plot_voronoi_cells" href="#pyleida._leida.Leida.plot_voronoi_cells">plot_voronoi_cells</a></code></li>
<li><code><a title="pyleida._leida.Leida.significant_states" href="#pyleida._leida.Leida.significant_states">significant_states</a></code></li>
<li><code><a title="pyleida._leida.Leida.state_rois" href="#pyleida._leida.Leida.state_rois">state_rois</a></code></li>
<li><code><a title="pyleida._leida.Leida.stats" href="#pyleida._leida.Leida.stats">stats</a></code></li>
<li><code><a title="pyleida._leida.Leida.transitions" href="#pyleida._leida.Leida.transitions">transitions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>